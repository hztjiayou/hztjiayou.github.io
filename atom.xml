<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monkey&amp;umpkin</title>
  
  <subtitle>The quieter you become, the more you are able to hear</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hztjiayou.github.io/"/>
  <updated>2020-04-27T14:39:14.457Z</updated>
  <id>https://hztjiayou.github.io/</id>
  
  <author>
    <name>Huangzhentao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[随笔]校园邮箱申请office 365教育版</title>
    <link href="https://hztjiayou.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-%E6%A0%A1%E5%9B%AD%E9%82%AE%E7%AE%B1%E7%94%B3%E8%AF%B7office365%E6%95%99%E8%82%B2%E7%89%88.html"/>
    <id>https://hztjiayou.github.io/2020/03/10/随笔-校园邮箱申请office365教育版.html</id>
    <published>2020-03-10T06:45:41.000Z</published>
    <updated>2020-04-27T14:39:14.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p><em>起因是因为在bilibili看到大神“稚晖君”的电脑使用onedrive同步文件，于是就去了解了下onedrive，发现个人onedrive用户只有5G使用空间，觉得太少了，顿时想起万能大淘宝，上淘宝一查，好多出售onedrive账号的，所以好奇这些卖家是如何有这么多大空间的账号，结果是方法各有千秋，其中就有使用假冒校园邮箱申请的，但是容易被官方删号，想到自己有校园网邮箱于是想着试一试….</em></p></blockquote><a id="more"></a><p>首先前提是你拥有一个校园网邮箱，网上也有好多使用假冒校园网邮箱注册空间的，但是容易被删号，一旦删号，所存的文件就再也找不回来了，所以最好还是有一个自己的校园邮箱为好。  </p><h3 id="注册教程"><a href="#注册教程" class="headerlink" title="注册教程"></a>注册教程</h3><ul><li>注册地址：<a href="https://signup.microsoft.com/signup?sku=Education" target="_blank" rel="noopener">https://signup.microsoft.com/signup?sku=Education</a><br><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/TIM20200310150616.png" alt="pic1"></li></ul><ul><li>选择学生或者教师都行，我这一步选择学生</li></ul><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/TIM20200310150804.png" alt="pic2"></p><ul><li>填写你的相关信息，密码等</li></ul><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/TIM20200310150906.png" alt="pic3"></p><ul><li>后续设置后，点击完成就可以进入office 365界面</li></ul><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/TIM20200310151044.png" alt="pic4"></p><p>在上面这个界面中，可以在线使用office几乎所有功能，除了没有visio。</p><p>然后就是查看onedrive了，通过这种方式申请的教育网office 365，以前是有5T空间的，但是现在只有1T空间了。到这里onedrive就可以正常使用了，在“我的电脑”里面添加一个onedrive账号就可使用了。</p><p>但是！！！有几点要注意，最好不存放重要文件，原因有以下几点：</p><ol><li><p>使用的是校园邮箱，邮箱有可能在你毕业之后被收回或无效，那么这个onedrive也就无效了。</p></li><li><p>使用校园邮箱申请的onedrive空间，你只是一个使用中，而校园的管理人员是可以删除你的账号以及查看你onedrive中存放的文件内容，这点很可怕有木有。</p></li></ol><p>关于上面第二点，如果不是管理员，最好就不要存放重要、敏感文件。当然如果有权限你也可以申请成为onedrive校园管理员，并且可以使用此方法判断是否已经存在管理员：</p><ul><li><p>登录office 365之后，点击左上角的“点点方框”，点击“admin”</p></li><li><p>阅读“成为管理员” 页面上的说明，然后选择“是，我想成为管理员”注意：如果未显示此选项，则表示已有 Office 365 管理员。</p></li><li><p>选择“验证”，然后按照步骤操作，证明你拥有或管理与 Office 365 服务关联的域名。请参阅验证域名。</p></li><li><p>完成上述操作后，登录 Office 365，然后选择“管理员”，以打开可以在其中管理服务的管理员中心。</p></li></ul><p>对于教育版office 365，微软官方的解释是：</p><blockquote><p>对于符合条件的学校，学生和其他个人都可注册 Office 365，并立即开始将它用于学校事务。他们需要的只是学校提供的电子邮件地址以及他们创建的密码。提供这两项信息，他们即可在其 PC、Mac 或其他设备上安装最新版本的 Office，并开始创建具有专业外观的文档、在云中使用 OneDrive for Business 进行共享和协作等。他们可以自己完成这项工作，快速提高工作效率，而无需等待其部门或学校实施正式部署流程。*</p></blockquote><blockquote><p>如果注册的第一个人的电子邮件地址，例如为“<a href="mailto:sara@contoso.edu" target="_blank" rel="noopener">sara@contoso.edu</a>”，那么该电子邮件地址的域部分“contoso.edu”将用作他们的 Office 365 域名。具有相同电子邮件地址域的所有后续用户（例如“<a href="mailto:rob@contoso.edu" target="_blank" rel="noopener">rob@contoso.edu</a>”）也将被添加到同一 Office 365 环境，并拥有相同的云服务。这两个人都可以使用 Office 365 的生产力工具集，<strong>但他们不能管理服务。例如，他们无法购买更多许可证、添加新用户或对其他人实施策略。IT 部门可以随时接管此环境，并以管理员身份为其管理服务。</strong>为此，请注册 Office 365，因为其他人也使用学校提供的电子邮件地址（例如“<a href="mailto:mark@contoso.edu" target="_blank" rel="noopener">mark@contoso.edu</a>”）。请选择左上角的应用启动器图标，选择“管理员”，然后阅读“成为管理员页上的说明。系统会要求你来验证是否拥有或管理与 Office 365 环境相关联的域名（“contoso.edu”）。这样做的原因是，如果你拥有或管理学校的域名，则必须已拥有有权限的 IT 角色。验证完毕后，即可自行提升为 Office 365 管理员角色。</p></blockquote><p>所以说最好是不要存放隐私文件在onedrive上，并且要做好随时备份。</p><p>目前我发现我学校在onedrive还未存在管理员，但是我也申请成为不了管理员，GG，所以且用且将就~</p><hr><p><strong>[参考文献]</strong></p><ul><li><p><a href="https://lykqq.com/%E6%95%99%E7%A8%8B/10.html" target="_blank" rel="noopener">注册教程</a></p></li><li><p><a href="https://docs.microsoft.com/zh-cn/microsoft-365/education/deploy/becoming-an-admin-in-office-365-education" target="_blank" rel="noopener">微软官方“成为 Office 365 教育版管理员”</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;起因是因为在bilibili看到大神“稚晖君”的电脑使用onedrive同步文件，于是就去了解了下onedrive，发现个人onedrive用户只有5G使用空间，觉得太少了，顿时想起万能大淘宝，上淘宝一查，好多出售onedrive账号的，所以好奇这些卖家是如何有这么多大空间的账号，结果是方法各有千秋，其中就有使用假冒校园邮箱申请的，但是容易被官方删号，想到自己有校园网邮箱于是想着试一试….&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://hztjiayou.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="随笔" scheme="https://hztjiayou.github.io/categories/%E8%BD%AF%E4%BB%B6/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="office365" scheme="https://hztjiayou.github.io/tags/office365/"/>
    
      <category term="onedrive" scheme="https://hztjiayou.github.io/tags/onedrive/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]OV7725入门使用</title>
    <link href="https://hztjiayou.github.io/2020/03/07/%E7%AC%94%E8%AE%B0-OV7725%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8.html"/>
    <id>https://hztjiayou.github.io/2020/03/07/笔记-OV7725入门使用.html</id>
    <published>2020-03-07T06:09:00.000Z</published>
    <updated>2020-04-27T15:05:07.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>最近在研究OV7725摄像头的使用，通过学习有了一定的了解，故记录下来。通过使用STM32f103单片机为主控，控制OV7725实时显示图像到野火3.2寸LCD。<br><a id="more"></a></p></blockquote><h3 id="摄像头简介"><a href="#摄像头简介" class="headerlink" title="摄像头简介"></a>摄像头简介</h3><p>摄像头图像传感器件可以分为CCD和CMOS，现在的智能手机大部分都是CMOS类型的数字摄像头。CCD和CMOS的区别，有以下几点：</p><ul><li>成像材料：CCD是“电荷耦合器件”（Charge Couple Device）的简称，而CMOS是“互补金属氧化半导体”（Complementary Metal Oxide Semiconductor）的简称。</li><li>功耗：CCD的像素由MOS电容构成，读取电荷信号，需要使用电压相当大（至少12V）的二相或三相或四相时序脉冲信号，才能有效的传输电荷。因此CCD的采集图像系统除了要多个电源之外，其外设电路也会消耗相当大功耗。而CMOS光电传感器只需要使用一个单电源5V或3V，功耗小，仅为CCD的1/8~1/10.</li><li>成像质量：CCD制作技术起步早，技术成熟，质量高。CMOS主要缺点是噪声高及灵敏度低，不过现在CMOS技术也在提升。</li></ul><p><br></p><h3 id="OV7725的硬件组成"><a href="#OV7725的硬件组成" class="headerlink" title="OV7725的硬件组成"></a>OV7725的硬件组成</h3><p>OV7725摄像头模块带有<strong>FIFO</strong>，其硬件由OV7725内部图像传感器，FIFO组成，其中内部图像传感器是不需要我们去了解的，其利用光学原理，把光信号转换为电信号，经过各种处理，这些信号存储成一个个像素点表示的数字图像，我们在使用OV7725时不需要了解图像传感器。<br>FIFO是一个“缓冲器”，本质是SRAM，因为STM32F1系列单片机主频低，内部SRAM容量低等原因，处理OV7725数据时较慢，无法及时处理，所以需要使用一个缓冲器，用来起缓冲作用，OV7725输出的数据首先存储在FIFO中，当存储一帧数据时，STM32开始读取数据，读完数据，FIFO再次被写入一帧数据，依次反复，完成摄像头显示。而STM32F4系列单片机的主频高，并且内含DCMI外设，可以使用DCMI外设直接控制摄像头，所以使用STM32F4系列单片机不需要使用FIFO。<br><br></p><h3 id="数据传输时序"><a href="#数据传输时序" class="headerlink" title="数据传输时序"></a>数据传输时序</h3><p>在OV7725的使用种涉及多个时序控制：<br>一是SCCB时序，这是STM32和OV7725之间的通讯方式，STM32通过SCCB时序向OV7725写入相关寄存器配置。<br>二是FIFO读写时序，FIFO的写入端连接的是OV7725输出端连接的是STM32。<br>三是摄像头输出的VGA时序，摄像头的输出VGA时序因为和FIFO写入时序类似，所以直接连接FIFO输入端。</p><h4 id="SCCB时序"><a href="#SCCB时序" class="headerlink" title="SCCB时序"></a>SCCB时序</h4><p>SCCB时序类似I2C协议，其实直接可以使用I2C协议代替SCCB，在OV7725的控制中，使用模拟I2C代替SCCB协议。<br>STM32通过SCCB协议向OV7725写入相关的寄存器配置，初始化OV7725等。</p><h4 id="FIFO时序"><a href="#FIFO时序" class="headerlink" title="FIFO时序"></a>FIFO时序</h4><p>首先要知道FIFO芯片的引脚：</p><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307185511765.png" alt="image-20200307185511765"></p><p>FIFO芯片同时支持写和读，所以它的输入和输出引脚是独立的，DI[0:7]和DO[0:7]。</p><p><strong>写时序</strong></p><p>写时序，当 <strong>WE</strong>引脚为低电平时，FIFO的写入处于使能状态，随着WCK的运转，DI[0:7]表示的数据将会按照地址递增的方式存入FIFO,当 <strong>WE</strong>引脚为高电平时候，关闭输入，FIFO将不会被写入。写数据时候，通常会把 <strong>WRST</strong>设置为低电平，将写指针复位到0地址。</p><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307190034429.png" alt="image-20200307190034429"></p><p><strong>读时序</strong></p><p>当 <strong>OE</strong>和 <strong>RE</strong>引脚均为低电平时，输出处于使能状态，随着RCK时钟的运转DO[0:7]将数据按地址递增的方式输出。读数据的时候，通常会把 <strong>RRST</strong>设置低电平，将读指针复位到0地址。</p><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307190306730.png" alt="image-20200307190306730"></p><h4 id="VGA时序"><a href="#VGA时序" class="headerlink" title="VGA时序"></a>VGA时序</h4><p>VGA时序是OV7725输出图像使用的时序，D2-D9 数据线在 PCLK 在上升沿阶段维持稳定， 并且会在 1 个像素同步时钟 PCLK 的驱动下发送 1 字节的数据信号，所以 2 个 PCLK 时钟可发送 1 个 RGB565 格式的像素数据。当 HREF 为高电平时， 像素数据依次传输，每传输完一行数据时，行同步信号 HREF 会输出一个电平跳变信号间隔开当前行和下一行的数据；一帧的图像由 N 行数据组成， 当 VSYNC 为低电平时，各行的像素数据依次传输， 每传输完一帧图像时，VSYNC 会输出一个电平跳变信号 。因为VGA时序与FIFO的写时序类似，故OV7725的输出接到FIFO的输入。</p><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307190655201.png" alt="image-20200307190655201"></p><p><br></p><h3 id="OV7725模块引出引脚"><a href="#OV7725模块引出引脚" class="headerlink" title="OV7725模块引出引脚"></a>OV7725模块引出引脚</h3><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307191010536.png" alt="image-20200307191010536"></p><p>从上图 可了解到， 与 OV7725 传感器像素输出相关的 PCLK 和 D[0:7]并没有引出， 因为这些引脚被连接到了 FIFO 的输入部分， OV7725 的像素输出时序与 FIFO 的写入数据时序是一致的，所以在 OV7725 时钟 PCLK 的驱动下， 它输出的数据会一个字节一个字节地被 FIFO 接收并存储起来。其中最为特殊的是 WEN 引脚，它与 OV7725 的 HREF 连接到一个与非门的输入，与非门的输出连接到 FIFO 的 WE 引脚，因此，当 WEN 与 HREF 均为高电平时， FIFO 的 WE为低电平，此时允许 OV7725 向 FIFO 写入数据。  </p><p>外部控制器通过控制 WEN 引脚， 可防止 OV7725 覆盖了还未被控制器读出的旧 FIFO数据。另外， 在 OV7725 输出时序中， 只有当 HREF 为高电平时， PCLK 驱动下 D[0:7]线表示的才是有效像素数据，因此，利用 HREF 控制 FIFO 的 WE 可以确保只有有效数据才被写入到 FIFO 中  。</p><p><br></p><h3 id="OV7725模块采集图像过程"><a href="#OV7725模块采集图像过程" class="headerlink" title="OV7725模块采集图像过程"></a>OV7725模块采集图像过程</h3><ul><li>利用 SIO_C、 SIO_D 引脚通过 SCCB 协议向 OV7725 的寄存器写入初始化配置。</li><li>初始化完成后， OV7725 传感器会使用 VGA 时序输出图像数据， 它的 VSYNC 会首先输出帧有效信号（低电平跳变） ， 当外部的控制器（如 STM32） 检测到该信号时， 把 WEN 引脚设置为高电平，并且使用 WRST 引脚复位 FIFO 的写指针到 0地址。  </li><li>随着 OV7725 继续按 VGA 时序输出图像数据， 它在传输每行有效数据时， HREF引脚都会持续输出高电平， 由于 WEN 和 HREF 同时为高电平输入至与非门， 使得其连接到 FIFO WE 引脚的输出为低电平，允许向 FIFO 写入数据， 所以在这期间， OV7725 通过它的 PCLK 和 D[0:7]信号线把图像数据存储到 FIFO 中， 由于前面复位了写指针，所以图像数据是从 FIFO 的 0 地址开始记录的。</li><li>各行图像数据持续传输至 FIFO， 受 HREF 控制的 WE 引脚确保了写入到 FIFO 中的都是有效的图像数据， OV7725 输出完一帧数据时， VSYNC 会再次输出帧有效信号，表示一帧图像已输出完成 。</li><li>控制器检测到上述 VSYNC 信号后，可知 FIFO 中已存储好一帧图像数据， 这时控制 WEN 引脚为低电平，使得 FIFO 禁止写入， 防止 OV7725 持续输出的下一帧数据覆盖当前 FIFO 数据 。</li><li>控制器使用 RRST 复位读指针到 FIFO 的 0 地址，然后通过 FIFO 的 RCLK 和DO[0:7]引脚， 从 0 地址开始把 FIFO 缓存的整帧图像数据读取出来。 在这期间，OV7725 是持续输出它采集到的图像数据的，但由于禁止写入 FIFO，这些数据被丢弃了。</li><li>控制器使用 WRST 复位写指针到 FIFO 的 0 地址，然后等待新的 VSYNC 有效信号到来，检测到后把 WEN 引脚设置为高电平， 恢复 OV7725 向 FIFO 的写入权限，OV7725 输出的新一帧图像数据会被写入到 FIFO 的 0 地址中， 重复上述过程。</li></ul><p>摄像头的整个控制过程：<br><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307191504642.png" alt="image-20200307191504642"></p><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/image-20200307191513989.png" alt="image-20200307191513989"></p><p><br></p><hr><p><strong>[参考文献]</strong></p><ul><li>《野火@零死角玩转STM——F103指南者》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;最近在研究OV7725摄像头的使用，通过学习有了一定的了解，故记录下来。通过使用STM32f103单片机为主控，控制OV7725实时显示图像到野火3.2寸LCD。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="硬件奇谈" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/"/>
    
      <category term="STM32" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/STM32/"/>
    
    
      <category term="stm32" scheme="https://hztjiayou.github.io/tags/stm32/"/>
    
      <category term="ov7725" scheme="https://hztjiayou.github.io/tags/ov7725/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]Linux系统分区</title>
    <link href="https://hztjiayou.github.io/2020/02/27/%E7%AC%94%E8%AE%B0-Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA.html"/>
    <id>https://hztjiayou.github.io/2020/02/27/笔记-Linux系统分区.html</id>
    <published>2020-02-27T06:25:16.000Z</published>
    <updated>2020-02-27T06:31:38.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><blockquote><p>linux系统分区笔记</p><a id="more"></a></blockquote><h4 id="1-系统分区"><a href="#1-系统分区" class="headerlink" title="1.系统分区"></a>1.系统分区</h4><p>在windows下分区方法是：硬盘分区-格式化-分配盘符</p><p>但是在linux下是：硬盘分区-格式化-分区设备文件名-挂载（分配盘符）</p><p>其中设备文件名是固定的，是系统自动分配的。</p><p><strong>总结</strong></p><ul><li><p>分区：把大硬盘分为小的逻辑分区</p></li><li><p>格式化：写入文件系统</p></li><li>分区设备文件名：给每个分区定义设备文件名</li><li>挂载：给每个分区分配挂载点</li></ul><p><strong>通俗的来说就是</strong>：你有一块硬盘，你要把它装配到你的LINUX电脑上，对于一整块硬盘你往往会把它分区，类似于win分为C、D、E等，这样方便管理，这就是把你的硬盘分为小的逻辑分区。好区之后需要对其进行格式化，格式化的目的不是清空所有文件！而是写入文件系统。然后要做的是给每个分区定义设备文件名，如：sda、sdb等（sda、sdb代表的是这一整块硬盘的名字），同时分配逻辑分区名，如sda1、sda2等（这代表的是一块硬盘分为1、2两个分区，但是一块硬盘只能支持4个主分区，也就是sda1、2、3、4，<strong>如果你要分4个以上分区，linux就会增加一个扩展分区，在扩展分区中分第5个分区，也就是第1个逻辑分区</strong>）。接下来就是挂载，挂载之前要先了解linux的系统结构是树状的。</p><p>其中<code>/</code>是整个系统的根目录，而<code>/boot</code>、<code>/etc</code>等是子目录，而<code>挂载</code>的意思就是把硬盘的某个分区挂到这些目录下，比如你可以把<code>/dev/sda3</code>挂载到<code>/</code>根目录下，那么你在<code>/</code>根目录下的文件就存储在<code>/dev/sda3</code>这个硬盘分区，同理你还可以把<code>/dev/sda1</code>挂载到<code>/boot</code>目录下，每一个目录都可以有自己独立的硬盘空间，这就是挂载。</p><h4 id="2-安装linux系统时分区配置"><a href="#2-安装linux系统时分区配置" class="headerlink" title="2.安装linux系统时分区配置"></a>2.安装linux系统时分区配置</h4><p>在安装linux时候，必须要分配的分区有：</p><ul><li><code>/</code>根分区。</li><li><code>swap分区</code>，交换分区，物理内存的两倍，不超过2GB。swap分区是在电脑物理内存不够用的时候，会使用swap交换内存，但是给其分配空间过大并没有多大的作用，反而还会占用硬盘空间，所以给其最多配置2GB。</li></ul><p>另外推荐分区：</p><ul><li><code>/boot</code>,启动分区，200MB。系统的启动需要一定额外的空间，如果不分配<code>/boot</code>分区，则启动所需要的空间就被包括在<code>/</code>根分区中，一点<code>/</code>的空间被使用完，那么系统就很有可能启动不了，所有往往要分一个<code>/boot</code>分区。</li><li><code>/home</code>，存储用户数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;linux系统分区笔记&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[随笔]linux从业方向</title>
    <link href="https://hztjiayou.github.io/2020/02/27/%E9%9A%8F%E7%AC%94-linux%E4%BB%8E%E4%B8%9A%E6%96%B9%E5%90%91.html"/>
    <id>https://hztjiayou.github.io/2020/02/27/随笔-linux从业方向.html</id>
    <published>2020-02-27T06:20:04.000Z</published>
    <updated>2020-02-27T06:38:01.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>常见的linux从业方向有：<strong>运维</strong>、<strong>开发</strong>、<strong>底层</strong>。</p><a id="more"></a></blockquote><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><ul><li>服务器运维：保证服务器不宕机，常常为“背锅侠”。</li><li>为开发搭建开发环境和提供技术支持：包括不限于如下服务的配置——ftp、dns、apache、iptable、oracle、mysql。还需要对服器状态进行监视。</li></ul><blockquote><p>===&gt;运维工程师需要学什么？</p><p>运维工程师需要懂很多的命令，开发环境的搭建，各种服务的配置，日常的维护等，很多的操作通过脚本能够方便的实现，所以运维工程师还需要东<code>shell</code>和<code>python</code>。推荐入门书籍：《鸟哥linux私房菜》。</p></blockquote><h3 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h3><ul><li>应用开发工程师：相对运维来说开发和底层要写相对较多的代码；简言之linux开发就是开发linux系统下的应用程序，就如同windows下的程序一样；linux开发工程师主要方向有两个：①服务器方向；②嵌入式方向。</li></ul><blockquote><p>===&gt;开发工程师需要掌握什么？</p><p>首先熟悉linux平台的API，包括IO操作、进程间通讯、linux环境、网络通讯等，推荐看APUE这本神书。另外还要懂脚本语言，包括shell、python;还有数据库，比如mysql、sqlite等至少懂一个。</p></blockquote><h3 id="底层开发"><a href="#底层开发" class="headerlink" title="底层开发"></a>底层开发</h3><ul><li>底层开发：主要是嵌入式方向，不过现在很多底层移植、适配的工作芯片厂商已经做好了，所以底层开发工程师的好去处是芯片厂商。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;常见的linux从业方向有：&lt;strong&gt;运维&lt;/strong&gt;、&lt;strong&gt;开发&lt;/strong&gt;、&lt;strong&gt;底层&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="随笔" scheme="https://hztjiayou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]manjaro使用技巧</title>
    <link href="https://hztjiayou.github.io/2020/02/27/%E7%AC%94%E8%AE%B0-manjaro%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html"/>
    <id>https://hztjiayou.github.io/2020/02/27/笔记-manjaro使用技巧.html</id>
    <published>2020-02-27T05:56:49.000Z</published>
    <updated>2020-02-27T06:17:48.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>在安装完manjaro系统过之后，还有一些细微的配置和技巧可以让manjaro使用起来更加方便，这篇文章归纳了杂乱的manjaro使用技巧、方法、常用软件等。</p><a id="more"></a></blockquote><h3 id="Dolphin文件管理使用技巧"><a href="#Dolphin文件管理使用技巧" class="headerlink" title="Dolphin文件管理使用技巧"></a>Dolphin文件管理使用技巧</h3><h4 id="在Dolphin中使用-“终端”-管理文件"><a href="#在Dolphin中使用-“终端”-管理文件" class="headerlink" title="在Dolphin中使用 “终端” 管理文件"></a>在Dolphin中使用 “终端” 管理文件</h4><p>通过使用F4按键，可以在dolphin当中直接启动终端。同样F4可以关闭终端。</p><h4 id="更改删除为确认后再删除"><a href="#更改删除为确认后再删除" class="headerlink" title="更改删除为确认后再删除"></a>更改删除为确认后再删除</h4><p>在dolphin之下删除文件，会不经过确认直接删除，这就有点危险了，所以可以在dolphin的配置当中-常规-确认当中 勾选删除文件。</p><h4 id="修改打开文件为双击"><a href="#修改打开文件为双击" class="headerlink" title="修改打开文件为双击"></a>修改打开文件为双击</h4><p>manjaro默认打开文件是单击鼠标左键即可打开，这不太符合我的使用习惯，可以在设置-&gt;外观中修改。</p><p><br></p><h3 id="使用wine安装的软件存放在哪？"><a href="#使用wine安装的软件存放在哪？" class="headerlink" title="使用wine安装的软件存放在哪？"></a>使用wine安装的软件存放在哪？</h3><p>wine安装的TIM，下载的文件存放在哪?</p><p><code>.deepinwine/Deepin-TIM/drive_c/users/hzt/My Documents/Tencent Files/1440327760/FileRec</code></p><p>同理其他使用wine安装的软件也可在此目录下找到。</p><p><br></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p>lspci|grep -i net #查看网卡信息</p></li><li><p>systemctl list-unit-files –state=enabled #查看已经启用的服务</p></li><li><p><strong>git 代理设置</strong>，推荐放到 .zshrc 中作为常用命令  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git-proxy()&#123;    </span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080    </span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">git-noproxy()&#123;   </span><br><span class="line">git config --global --unset http.proxy    </span><br><span class="line">git config --global --unset https.proxy </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 TIM DPI（高分屏）：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ env WINEPREFIX=<span class="hljs-string">"<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-TIM"</span> winecfg</span><br></pre></td></tr></table></figure><p>在 <code>Graphics</code> 中将 DPI 调整为 <code>120</code> 。</p></li><li><p>设置 wechat DPI（高分屏）：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ env WINEPREFIX=<span class="hljs-string">"<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-WeChat"</span> winecfg</span><br></pre></td></tr></table></figure><p>在 <code>Graphics</code> 中将 DPI 调整为 <code>120</code> 。</p></li></ol><p><br></p><h3 id="开启wifi热点"><a href="#开启wifi热点" class="headerlink" title="开启wifi热点"></a>开启wifi热点</h3><p>win10在连接wifi之后，可以开启热点让手机连接，同样manjaro（linux）也可以。linux下可以使用 <code>creat_ap</code> 实现。</p><ol><li><p><code>sudo pacman -S create_ap</code></p></li><li><p><code>iw dev</code> 查看网卡名称，Interface 后面的就是网卡名称</p></li><li><p>使用 <code>sudo create_ap wlp5s0  wlp5s0 wifi名称 密码</code> 创建热点</p></li><li><p>如果报错“ERROR: Your adapter can not transmit to channel 36, frequency band 5GHz.”</p><ol><li><p>编辑 <code>sudo vim /usr/bin/create_ap</code></p></li><li><p>Find the function <code>is_wifi_connected</code> and replace it with:</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_wifi_connected() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Finish!!!</p></li></ol><p><br></p><h3 id="录屏闪屏"><a href="#录屏闪屏" class="headerlink" title="录屏闪屏"></a>录屏闪屏</h3><p>使用相关软件录屏时候，会出现闪屏情况，通过以下方式应该可以解决。</p><ol><li>只要开启显示帧数就能解决，基本和录制方式以及工具帧数等无关。</li><li>比较可靠的方式，直接选择在设置-&gt;显示与监控-&gt;混成器中关闭避免撕裂即可解决;</li></ol><p><br></p><h3 id="相关软件推荐"><a href="#相关软件推荐" class="headerlink" title="相关软件推荐"></a>相关软件推荐</h3><ol><li><p><strong>redshift</strong> 根据你的周边调整你屏幕的色温。当你夜晚在屏幕前工作时，它也许能帮助你减少对眼睛的伤害；</p></li><li><p><strong>i-nex</strong> 小而全的系统信息查看软件；</p></li><li><p><strong>bleachbit</strong> 快速释放磁盘空间并不知疲倦地守卫你的隐私。释放缓存，删除 cookie，清除互联网浏览历史，清理临时文件，删除日志，以及更多功能…</p></li><li><p><strong>ccal</strong> 终端农历日历，终端启动ccal；</p></li><li><p><strong>variety</strong> 随即更换壁纸的应用；</p></li><li><p><strong>wiznote</strong> 为知笔记；</p></li><li><p><strong>meld</strong> 文本比较；</p></li><li><p><strong>goldendict</strong> 词典软件!!!!!!!!!!!!!!!!!</p><blockquote><p>以上软件使用 <strong>yay</strong>安装</p></blockquote></li></ol><p>有意思软件：</p><ol><li><p><strong>cmatrix</strong> 终端从上往下输出无尽的字符串,类似&lt;&lt;黑客帝国&gt;&gt;中的矩阵效果，终端运行 cmatrix ；</p></li><li><p><strong>screenfetch</strong></p></li><li><p><strong>neofetch</strong></p></li><li><p><strong>lolcat</strong> 一个在 Linux 终端中输出彩虹特效的命令行工具</p></li><li><p><strong>figlet</strong></p></li></ol><p><br></p><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>开机自启动程序：这时候可以在<em>开机和关机=&gt;自动启动</em>里设置，可以添加应用程序也可以添加脚本，当然也可以直接把可执行文件复制到<code>～/.config/autostart</code> 目录下</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在安装完manjaro系统过之后，还有一些细微的配置和技巧可以让manjaro使用起来更加方便，这篇文章归纳了杂乱的manjaro使用技巧、方法、常用软件等。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
      <category term="manjaro" scheme="https://hztjiayou.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]linux服务器内存占用率大</title>
    <link href="https://hztjiayou.github.io/2020/02/25/%E7%AC%94%E8%AE%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E5%A4%A7.html"/>
    <id>https://hztjiayou.github.io/2020/02/25/笔记-服务器内存占用率大.html</id>
    <published>2020-02-25T02:20:03.000Z</published>
    <updated>2020-02-25T02:33:42.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>查看宝塔服务器状态监视，发现内存占用比平常大，平常只有30%左右的占用率，现在有70%的占用率，觉得异常，在释放内存之后仍然占用率很大。</p><a id="more"></a></blockquote><p>点击释放内存之后，内存占用率还是很大，于是重启了php-fpm和nginx,重启之后并没有什么变化。</p><p>使用命令查看占用内存最大的10个进程：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | sort -k4nr |head -n 10</span><br></pre></td></tr></table></figure><p>查看内存占用最大的进程有无异样，如有异样，可以使用以下命令杀掉进程：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">kill</span> -9 $(ps aux | grep 进程名 |grep -v grep| awk <span class="hljs-string">'&#123;print $2&#125;'</span>)</span><br></pre></td></tr></table></figure><p>不要凭个人直觉杀掉进程，需要找出原因确定之后，再去执行，防止服务器出现问题。</p><p>另外还有一个查看内存占用最大进程的命令</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux| grep -v <span class="hljs-string">"USER"</span> |sort -n -r -k 4 |awk <span class="hljs-string">'NR==1&#123; print $0&#125;'</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><hr><p>[参考资料]</p><ol><li><a href="https://blog.csdn.net/sbtmbj2010/article/details/45097747" target="_blank" rel="noopener">CSDN</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查看宝塔服务器状态监视，发现内存占用比平常大，平常只有30%左右的占用率，现在有70%的占用率，觉得异常，在释放内存之后仍然占用率很大。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="云服务器" scheme="https://hztjiayou.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
      <category term="云服务器" scheme="https://hztjiayou.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>[随笔]关于2019年的总结</title>
    <link href="https://hztjiayou.github.io/2020/02/20/%E9%9A%8F%E7%AC%94-%E5%85%B3%E4%BA%8E2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>https://hztjiayou.github.io/2020/02/20/随笔-关于2019年的总结.html</id>
    <published>2020-02-20T03:45:12.000Z</published>
    <updated>2020-02-20T06:54:48.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>2019过去好久好久了，想过写总结一直下不了手，也许是懒，也许是感觉愧对了这一年愧于下笔，今天是2020/02/20，今年很多事情因为碰上这么一个疫情的原因而改变，这两天将要出2019考研的成绩，从考完到现在，自己一直就没有再去想这件事情，但是现在有些许感触，2019这一年过的很快很快，但总的来说没有任何实质的收获……..</p><a id="more"></a></blockquote><p>这两天即将公布2019考研成绩，本来不错的心态在这时又有些紧绷了，从12月考完到现在，一直没有去回忆这件事情，因为这件事情没有给自己的2019画上一个圆满的句号。2019对自己来说是糟糕的一年，不是因为别人的原因，而仅仅是自己的原因，家里人，朋友，所有人都做的很好，但是自己做的很糟糕，本应该是丰收的一年，到头来颗粒无收，只能看着别人丰收。</p><p>付出了时间、金钱，不仅没有收获而且自己也过的很难受。时间要回到19年的上半年，当时的踌躇满志，精力旺盛，每天早上6点起床，晚上11点回宿舍，以这种拼搏的状态持续到了暑假，暑假选择了留学校复习，学校不让住，只能在校外租房住，而现在回想起来，自己的变化就是从暑开始的，那段时间的学习方法等有很大的问题，太多的时间花在了看视频上了，而且想着广撒网，多条战线同时拉开，最后进入暑假基础复习还没有过一遍，或许这也不是问题，但是加上大家都是在学院提供的教室复习，和别人一对比，发现别人会做的简单的题目自己都不会，这让自己的心态就开始有了细微的变化，后续就是每天雷的半死，但是因为基础不牢导致后面越学越空洞，就这样一直持续到了开学，而开学的就是心态炸裂的喷涌口，心里或许是觉得开学热闹了，可以放松一段时间，可是一放松就提不起来了，每天去教室，坐在那感觉无比的煎熬，以前从没有这种感受，身边的人都在学习，但是就自己学不进去，坐在教室那个位置上感觉浑身不自在，这时候我知道我已经崩了，每天想着自己没时间了，还有好多的数没有看，但是每天看书的效率又很低，心里的预期和实际行动产生了巨大的差异，导致后期完全看不进书，这样的一直恶心循环，再加上当时自己心里的压力很大，那段时间过的很压抑。</p><p>以前就听说考研是一场智力战，但更是一场心理战，到后面才有深的认识，有些人能够很好的度过那段时间，有些人却是止步于那段时间。</p><hr><p>马上出成绩了，看着别人收获时候的喜悦，心里不知是什么滋味，喜？愁？或是嫉？，无论怎样，那都是人家付出所得的结果，理所应当，更好的选择是祝福，付出了自然就有收获。</p><p>人生中有些坎总得跨过去的，没有跨过去，它就一直在那，所有命运馈赠的背后早已标好了价格，收获了放松和玩乐，自然就失去了丰收的果实。有些坎你不跨过去，可以选择另外的路，但另外的路，定充满着更多的坎坷。2019过的很阴沉，希望自己能让20年的阳光照破19年的迷雾。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2019过去好久好久了，想过写总结一直下不了手，也许是懒，也许是感觉愧对了这一年愧于下笔，今天是2020/02/20，今年很多事情因为碰上这么一个疫情的原因而改变，这两天将要出2019考研的成绩，从考完到现在，自己一直就没有再去想这件事情，但是现在有些许感触，2019这一年过的很快很快，但总的来说没有任何实质的收获……..&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="考研" scheme="https://hztjiayou.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://hztjiayou.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="总结" scheme="https://hztjiayou.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]hexo部署到个人服务器</title>
    <link href="https://hztjiayou.github.io/2020/02/18/%E7%AC%94%E8%AE%B0-hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>https://hztjiayou.github.io/2020/02/18/笔记-hexo部署到个人服务器.html</id>
    <published>2020-02-18T06:41:32.000Z</published>
    <updated>2020-02-19T13:37:21.611Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>本片文章记录把HEXO博客部署到华为云服务器，几个月前购入了一台云服务器ESC，充满了好奇，一股脑的投入到了服务器的世界，这段时间部署了第一个wordpress博客，搭建个人网盘、图床，后续转到Typecho博客，但是配置的博客时钟没有满足自己的要求，比如wordpress本身不能很好的支持markdown，这不能接受，故后面转到了Typecho，但是种种原因都没有很好的体验，相比起来还是喜欢hexo+icaus这个主题的配置，故而想着把HEXO博客部署到服务器上，一来因为github上的仓库是开放的，文章多了安全，二来追求更高的访问速度。<br><a id="more"></a></p></blockquote><p>主要步骤是在服务器上构建一个git仓库，并且使用Nginx指向hexo文件目录，再使用宝塔面板创建一个网站，把文件地址选择为上面的nginx指向的文件目录即可。再本地通过 <code>git bash</code>使用命令部署到服务器，部署需要输入用户密码。</p><p>通过使用 <code>宝塔面板</code>帮助，已经能够顺利的部署网站。只需要在 <code>网站</code>选项创建一个新的网站，把文件存放地址选择前端代码所在的文件夹</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>原来的hexo博客评论系统使用的是 <code>valine</code>,再部署到服务器之后在评论框下出现了以下错误</p><blockquote><p><em>Code 403:访问被api域名白名单拒绝，请检查你的安全域名设置。</em></p></blockquote><p>查阅资料后，发现解决办法，需要在lencloud网站的<strong>安全中心</strong>中添加当前博客的域名或者IP地址。</p><hr><h4 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h4><p>执行 <code>hexo d</code>命令明显加快。以前部署在Github page上因为国内网络环境的原因，打开速度很慢，现在打开网页明显比以前快。</p><hr><p>附加一句：不想开新文章写了，这两天花费一个下午和一个上午折腾了下黑苹果，感想就是：安装简单，驱动折腾死人，弃坑，再也不折腾了，或许可以考虑去淘宝交点智商税…….</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本片文章记录把HEXO博客部署到华为云服务器，几个月前购入了一台云服务器ESC，充满了好奇，一股脑的投入到了服务器的世界，这段时间部署了第一个wordpress博客，搭建个人网盘、图床，后续转到Typecho博客，但是配置的博客时钟没有满足自己的要求，比如wordpress本身不能很好的支持markdown，这不能接受，故后面转到了Typecho，但是种种原因都没有很好的体验，相比起来还是喜欢hexo+icaus这个主题的配置，故而想着把HEXO博客部署到服务器上，一来因为github上的仓库是开放的，文章多了安全，二来追求更高的访问速度。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="博客" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://hztjiayou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]STM32串口USART</title>
    <link href="https://hztjiayou.github.io/2020/02/16/%E7%AC%94%E8%AE%B0-STM32%E4%B8%B2%E5%8F%A3USART.html"/>
    <id>https://hztjiayou.github.io/2020/02/16/笔记-STM32串口USART.html</id>
    <published>2020-02-16T15:32:35.000Z</published>
    <updated>2020-04-27T15:06:13.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>记录STM32串口USART的学习笔记，包括 <strong>理论部分</strong>和 <strong>代码</strong>部分，理论部分讲解USART工作原理，涉及寄存器的控制，代码部分完全由库函数编写完成。<br><a id="more"></a></p></blockquote><h2 id="一-工作原理"><a href="#一-工作原理" class="headerlink" title="一.工作原理"></a>一.工作原理</h2><h3 id="1-USART功能框图"><a href="#1-USART功能框图" class="headerlink" title="1.USART功能框图"></a>1.USART功能框图</h3><p>关于USART，首先要了解有关串口的基本知识，比如：同步、异步，单工、双工、半双工，串行、并行等基本概念，在51单片机中也有串口，叫做UART，和stm32单片机的串口相比少了一个S，stm32单片机的串口USART，中的S代表着同步的意思，表示其能使用同步通讯方式，使用异步通信方式的串口只需要TX和RX两根数据线即可，而同步通信方式还需要一根时钟线。stm32f10x系列芯片中包含5个串口，三个USART和两个UART，而USART1的时钟来源是APB2总线，时钟频率能达到72Mhz，其他串口最大时钟频率为32Mhz，这篇笔记以USART1为例。</p><p>首先要讲解的是USART的功能框图，图片来源野火开发板资料，如下：<br><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/2020/02/16/usart.png" alt="USART功能框图"></p><h4 id="1-1-引脚"><a href="#1-1-引脚" class="headerlink" title="1.1 引脚"></a>1.1 引脚</h4><p>关于引脚在此关注一下：TX、RX、nRTS、nCTS、SCLK。<br><strong>TX &amp; RX</strong>:发送引脚 和 接收引脚<br>两个硬件流控制引脚：<br><strong>nRTS</strong>：请求以发送引脚，n表示低电平有效，USART准备接收新数据时候，nRTS变为低电平，接收完成变为高电平。<br><strong>nCTS</strong>:清除一发送引脚，n表示低电平有效，发送器在发送下一帧数据时候检测nCTS,如果为低电平，则可以发送数据，否则在发送完前一帧数据后停止发送。<br><strong>SCLK</strong>：发送器时钟输出引脚，<em>仅用于同步模式</em>。</p><h4 id="1-2-数据寄存器USART-DR"><a href="#1-2-数据寄存器USART-DR" class="headerlink" title="1.2 数据寄存器USART_DR"></a>1.2 数据寄存器USART_DR</h4><p>USART外设包含这几个主要寄存器：</p><ul><li>USART_DR：数据寄存器</li><li>USART_SR：状态寄存器</li><li>USART_BRR：波特率寄存器</li><li>USART_CR1：控制寄存器1</li></ul><p>其中上图中的2表示的是数据寄存器USART_DR,USART_DR只有9位有效，并且第九位是否有效取决于USART控制器寄存器USART_CR1的M位设置，M=0,则为8位数据字长，M=1，则为9位数据字长，一般使用8位数据字长。<br>USART_DR包含两个寄存器 <strong>TDR</strong>和 <strong>RDR</strong>，前者是专门用于 <strong>发送</strong> 的 <strong>可写</strong>寄存器，后者是专门用于 <strong>接收</strong> 的 <strong>可读</strong> 寄存器。<br>串口通信是一个位一个位的传输，发送数据时候总线把数据为TDR寄存器，TDR寄存器数据转移到<strong>发送移位寄存器</strong>，然后把数据发送出去，接收数据时候把接收到的数据一位一位顺序保存到<strong>接收移位寄存器</strong>，再转移到RDR寄存器，再传给总线，配合上图2部分理解。</p><h4 id="1-3-控制器"><a href="#1-3-控制器" class="headerlink" title="1.3 控制器"></a>1.3 控制器</h4><p>USART有专门控制发送的发送器和专门控制接收的接收器，还有唤醒单元，中断控制等，控制器分为<strong>发送器控制</strong>和<strong>接收器控制</strong>，使用USART之前向USART_CR1寄存器的UE位置1，使能USART.</p><h5 id="1-3-1-发送器控制及字符帧组成"><a href="#1-3-1-发送器控制及字符帧组成" class="headerlink" title="1.3.1 发送器控制及字符帧组成"></a>1.3.1 发送器控制及字符帧组成</h5><p><strong>将USART_CR1寄存器发送使能位 TE 置1，启动数据发送</strong>，发送移位寄存器在TX引脚输出，低位在前，高位在后。发送的数据为字符帧，一个字符帧由三个部分组成，<strong>起始位</strong>、<strong>数据帧</strong>、<strong>停止位</strong>。<br><strong>起始位</strong>是一个位周期的低电平，位周期是每一位数据占用的时间。<br><strong>数据帧</strong>表示要发送的数据，8位或者9位，从低位开始传输。<br><strong>停止位</strong>是一定时间周期的高电平，这个一定时间可以是0.5、1、1.5、2个周期，默认使用一个周期的停止位。通过USART_CR2的stop[1:0]控制。<br><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/2020/02/16/shujuzhen.png" alt="发送时序图"><br><strong>发送数据的流程</strong>：发送使能位TE置1，发送器先发送一个空闲帧（一个数据帧长度的高电平），接着往USART_DR寄存器的 发送数据寄存器TDR写入数据，发送寄存器 把数据全部转到 移位寄存器 后，UDART_SR的TXE位置1，表示 发送寄存器 为空，发送移位寄存器 发送最后一个数据之后，USART_SR的TC位置1，表示数据传输完成。如果USART_CR1寄存器的TCIE位置1，可产生中断。</p><h5 id="1-3-2-接收器控制"><a href="#1-3-2-接收器控制" class="headerlink" title="1.3.2 接收器控制"></a>1.3.2 接收器控制</h5><p><strong>接收数据流程</strong>：USART_CR1寄存器的RE置1，使能USART接收，接收器在RX线上开始搜索起始位，确定起始位之后，根据RX电平状态，把数据放在 接收移位寄存器 中，接收完成<strong>后</strong>，把数据移到 接收数据寄存器RDR 内，并把USART_SR寄存器的RXNE位置1。如果USART_CR1的RXNEIE置1，可产生中断。</p><h4 id="1-4-波特率"><a href="#1-4-波特率" class="headerlink" title="1.4 波特率"></a>1.4 波特率</h4><p>波特率表示数据传输的速率，波特率越大，速率越快，USART发送器和接收器使用相同的波特率，波特率计算公式如下：<br><strong>波特率=$$\frac{f_{ck}}{16*USARTDIV}$$</strong><br>fck表示时钟频率。<br><strong>USARTDIV</strong>是一个存放在波特率寄存器USART_BRR中的无符号定点数。DIV_Mantissa[15:4]定义整数部分，DIV_Fraction[3:0]表示小数部分。</p><p><strong>例1</strong>DIV_Mantissa=24（0x18）,DIV_Fraction=10(0x0A),则USART_BRR的值为0x18A。那么USARTDIV的小数部分为 10/16=0.625，则USARTDIV等于24.625。<br><strong>例2</strong>以USART1为例子，为了得到115200的波特率，则USARTDIV该取多少？<br>由波特率公式一个算的UDARTDIV等于39.0625，可以知道DIV_Fraction=16 * 0.0625=1=0x01(取最近似值)，DIV_Mantissa=39=0x27,故USART_BRR等于0x271。</p><h4 id="1-5-校验控制"><a href="#1-5-校验控制" class="headerlink" title="1.5 校验控制"></a>1.5 校验控制</h4><p>使用奇偶校验则串口传输长度是8位数据帧加上1位校验位共9位，此时USART_CR1的M位置1,。USART_CR1寄存器的PCE位置1，可以启动奇偶位校验控制位。<br>奇偶校验由硬件自动完成，发送数据帧自动加校验位，接收时自动验证。此时的一个字符帧为：<br>起始位+数据帧+校验位+停止位</p><h4 id="1-6-中断控制"><a href="#1-6-中断控制" class="headerlink" title="1.6 中断控制"></a>1.6 中断控制</h4><p>USART有多个中断请求事件，其中有TXE、TC、RXNE中断时间比较常用，如下表格</p><table><thead><tr><th>中断事件</th><th>事件标志</th><th>使能控制位</th></tr></thead><tbody><tr><td>发送数据寄存器位空</td><td><strong>TXE</strong></td><td>TXEIE</td></tr><tr><td>CTS标志</td><td>CTS</td><td>CTSIE</td></tr><tr><td>发送完成</td><td><strong>TC</strong></td><td>TCIE</td></tr><tr><td>准备好读取接收到的数据</td><td><strong>RXNE</strong></td><td>RXNEIE</td></tr><tr><td>检测到上溢错误</td><td>ORE</td><td>RXNEIE</td></tr><tr><td>检测到空闲线路</td><td>IDLE</td><td>IDLEIE</td></tr><tr><td>奇偶校验错误</td><td>PE</td><td>PEIE</td></tr><tr><td>断路标志</td><td>LBD</td><td>LBDIE</td></tr><tr><td>多缓冲通信中噪声、上溢、帧错误</td><td>NF/ORE/FE</td><td>EIE</td></tr></tbody></table><h2 id="二-代码"><a href="#二-代码" class="headerlink" title="二.代码"></a>二.代码</h2><p>标准库函数对每一个外设都建立了一个初始哈结构体，USART的初始化结构体就是USART_InitTypDef,结构体成员用于设置外设工作参数，并由外设初始化函数调用，如USART_Init(),初始化结构体设定的参数将会通过设置外设相应的寄存器，完成配置外设的工作。<strong>初始化结构体和初始化库函数配合使用是标准库的精髓所在</strong>。</p><h3 id="USART的初始化结构体："><a href="#USART的初始化结构体：" class="headerlink" title="USART的初始化结构体："></a>USART的初始化结构体：</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_BaudRate;<span class="hljs-comment">//波特率</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_WordLength;<span class="hljs-comment">//字长，通过USART_CR1寄存器的M位控制</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_StopBits;<span class="hljs-comment">//停止位</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_Parity;<span class="hljs-comment">//校验位</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_Mode;<span class="hljs-comment">//USART模式</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> USART_HardwareFlowControl;<span class="hljs-comment">//硬件流控制</span></span><br><span class="line">&#125;USART_InitTypeDef;</span><br></pre></td></tr></table></figure><h3 id="USART时钟初始化结构体"><a href="#USART时钟初始化结构体" class="headerlink" title="USART时钟初始化结构体"></a>USART时钟初始化结构体</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> USART_Clock;<span class="hljs-comment">//时钟使能控制</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> USART_CPOL;<span class="hljs-comment">//时钟极性</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> USART_CPHA;<span class="hljs-comment">//时钟相位</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> USART_LastBit;<span class="hljs-comment">//最尾位时钟脉冲</span></span><br><span class="line">&#125;USART_ClockCInitTypeDef;</span><br></pre></td></tr></table></figure><p>在使用同步模式的时候需要配置时钟初始化结构体。</p><h3 id="USART串口实验，代码编写"><a href="#USART串口实验，代码编写" class="headerlink" title="USART串口实验，代码编写"></a>USART串口实验，代码编写</h3><ol><li>使能TX和RX引脚的GPIO时钟和USART时钟。</li><li>初始化GPIO，并将GPIO复用到USART。</li><li>配置USART参数。</li><li>配置中断控制器，并使能USART接受中断。</li><li>使能USART。</li><li>在USART接受中断服务函数实现中断功能。</li></ol><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">USART_Config</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//配置USART的TX和RX引脚的GPIO</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = </span><br><span class="line">    .....</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = </span><br><span class="line">    .....</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//配置USART的工作参数</span></span><br><span class="line">    USART_InitStructure.USART_BaudRate = </span><br><span class="line">   .....</span><br><span class="line">    USART_Init(USART1,ENABLE);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//配置NVIC嵌套向量中断控制</span></span><br><span class="line">    <span class="hljs-comment">//嵌套向量中断控制器组选择</span></span><br><span class="line">NVIC_PriorityCroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = </span><br><span class="line">    ....</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//使能串口中断,发送寄存器为空中断</span></span><br><span class="line">    USART_ITConfig(USART1,USART_IT_TXE,ENABLE)</span><br><span class="line">    <span class="hljs-comment">//使能串口</span></span><br><span class="line">    USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码块完成USART的初始化配置，后续需要完成USART串口发送函数的编写。</p><h3 id="字符发送函数"><a href="#字符发送函数" class="headerlink" title="字符发送函数"></a>字符发送函数</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/************************发送一个字符************************/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">USART_SendByte</span><span class="hljs-params">(USART_TypeDef *pUSARTx,<span class="hljs-keyword">uint8_t</span> ch)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">//发送一个字节数据到USART</span></span><br><span class="line">    USART_SendData(pUSARTx,ch);</span><br><span class="line">    <span class="hljs-comment">//等待发送数据寄存器为空</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/************************发送字符串************************/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">USART_SendString</span><span class="hljs-params">(USART_TypeDef *pUSARTx,<span class="hljs-keyword">char</span> *str)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        USART_SendByte(pUSARTx,*(str + k));</span><br><span class="line">        k++;</span><br><span class="line">    &#125;<span class="hljs-keyword">while</span>(*(str + k)!=<span class="hljs-string">'\0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">while</span>(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC) == RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;记录STM32串口USART的学习笔记，包括 &lt;strong&gt;理论部分&lt;/strong&gt;和 &lt;strong&gt;代码&lt;/strong&gt;部分，理论部分讲解USART工作原理，涉及寄存器的控制，代码部分完全由库函数编写完成。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="硬件奇谈" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/"/>
    
      <category term="STM32" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/STM32/"/>
    
    
      <category term="stm32" scheme="https://hztjiayou.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>[笔记]vmware安装manjaro kde分辨率调整问题</title>
    <link href="https://hztjiayou.github.io/2020/02/14/vmware%E5%AE%89%E8%A3%85manjaro-kde%E5%88%86%E8%BE%A8%E7%8E%87%E8%B0%83%E6%95%B4%E9%97%AE%E9%A2%98.html"/>
    <id>https://hztjiayou.github.io/2020/02/14/vmware安装manjaro-kde分辨率调整问题.html</id>
    <published>2020-02-14T13:38:41.000Z</published>
    <updated>2020-02-19T13:50:55.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>使用vmware workstation安装manjaro kde每次都出现无法调整分辨率问题，通过此方法可以解决这个问题。</p><a id="more"></a></blockquote><p><strong>问题描述：</strong>使用vmware安装manjaro KDE之后无法调整分辨率，在系统设置中更换分辨率，之后又自动跳转回800x600的分辨率。</p><p><strong>解决方法：</strong><br>Step1. 安装open-vm-tools</p><ul><li><code>sudo pacman -Sy open-vm-tools</code></li><li><code>sudo pacman -Sy gtkmm</code></li><li><code>sudo pacman -Sy gtkmm3</code></li><li>重启</li></ul><p>Step2. 设置open-vm-tools为自启动，开机后不是全屏，尝试该命令：<br><code>systemctl restart vmtoolsd.service</code><br>并且设置为自启动:<br><code>systemctl enable vmtoolsd.service</code><br>但是此处有一个Bug,设置了开机自启动也没用，仍然需要手动启动。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;使用vmware workstation安装manjaro kde每次都出现无法调整分辨率问题，通过此方法可以解决这个问题。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
      <category term="manjaro" scheme="https://hztjiayou.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title> [笔记]Cjson在STM32中的使用</title>
    <link href="https://hztjiayou.github.io/2020/02/07/Cjson%E5%9C%A8STM32%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>https://hztjiayou.github.io/2020/02/07/Cjson在STM32中的使用.html</id>
    <published>2020-02-07T13:45:11.000Z</published>
    <updated>2020-04-27T15:06:22.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>目前对于ESP8266的了解还远远不够，只了解esp8266这款芯片是自带 <strong>mcu</strong>的，网上搜索的关于ESP8266的教程都是基于ESP8266开发板展开的，所以开始对于如何使用这个模块很是懵逼，通过查找资料，对其有一定的了解，并且了解到在和stm32一起使用的时候需要使用AT相关的指令，目前对于这一块还不是很了解，但通过开发板的例程还是可以分析一点门路的。</p><a id="more"></a></blockquote><p>今天在一个博客上看到一篇关于 使用<strong>stm32+esp8266</strong>做实时天气预报的帖子，通过esp8266链接“丫丫天气”的服务器API接口，通过 <strong>GET</strong>请求数据。这里有一个关键点，也一直是困扰我的，就是通过服务器请求回来的数据是json格式的，所以如何从一堆的数据中提取出关键的数据呢？这篇文章给出他的解决方案，就是 <strong>cjson</strong>。</p><p>原博客的地址是：<a href="http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=1677425&amp;page=1#pid7189332" target="_blank" rel="noopener"> STM32+ESP8266获取天气信息并显示到lcd</a></p><p>作者关于处理json数据的原话是：<strong>从获取到的信息可以看到，数据是json格式，而且没有gbk编码，要正常显示到LCD的话，要用cjson把我们需要的字段取出，并转换成gbk。</strong></p><p>关于后面的 <strong>gbk</strong>编码我还没了解，我先去了解了下什么是cjson？</p><p>JSON全称为Javascript Object Notation,是一种轻量级的数据交换格式，越来越多的嵌入式设备需要联网进行数据交互，而json就是其中一个比较流行的数据交换格式，具有多种语言版本，在stm32使用中使用的是C语言版本。</p><p>json的使用，这里通过一个网上简单的例子说明。</p><ul><li>创建一个JSON对象，并加入数据。</li><li>JSON对象转换为字符串。</li><li>将字符串解析为JSON对象，并从中提取数据。</li></ul><p><strong>Step1</strong> .创建JSON对象，并向其中加入数据</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建JSON对象</span></span><br><span class="line">cJSON *info;</span><br><span class="line">info=cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//添加数据</span></span><br><span class="line">cJSON_AddStringToObject(info,<span class="hljs-string">"sex"</span>,<span class="hljs-string">"male"</span>);</span><br><span class="line">cJSON_AddNumberToObject(info,<span class="hljs-string">"age"</span>,<span class="hljs-string">"20"</span>);</span><br><span class="line">cJSON_AddStringToObject(info,<span class="hljs-string">"name"</span>,<span class="hljs-string">"weijun"</span>);</span><br></pre></td></tr></table></figure><p><strong>Step2</strong> .将JSON对象转换为字符串</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//字符指针</span></span><br><span class="line"><span class="hljs-keyword">char</span> *jsonStr;</span><br><span class="line"><span class="hljs-comment">//转换函数</span></span><br><span class="line">jsonStr=cJSON_Print(info);</span><br></pre></td></tr></table></figure><p><strong>Step3</strong> .将字符串转换为JSON并提取数据</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建JSON对象</span></span><br><span class="line">cJSON *root;</span><br><span class="line">cJSON *name;</span><br><span class="line"><span class="hljs-keyword">char</span> *exeStr;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//将json数据解析成json结构体</span></span><br><span class="line">root=cJSON_Parse(jsonStr);</span><br><span class="line"><span class="hljs-keyword">if</span>(!root)&#123;</span><br><span class="line">    print(<span class="hljs-string">"get root failed!\n"</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error before: [%s]\n"</span>, cJSON_GetErrorPtr());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//获取数据</span></span><br><span class="line">name = cJSON_GetObjectItem(root, <span class="hljs-string">"name"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!name) &#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"get name faild !\n"</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error before: [%s]\n"</span>, cJSON_GetErrorPtr());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//转移数据到指针</span></span><br><span class="line">exeStr = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(name-&gt;valuestring));</span><br><span class="line"><span class="hljs-built_in">sprintf</span>(exeStr,<span class="hljs-string">"%s"</span>,name-valuestring);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//内存回收</span></span><br><span class="line">cJSON_Delete(root);</span><br></pre></td></tr></table></figure><p>或者另外一个例子用来表示json的使用。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">char</span>* pszJsonText = <span class="hljs-string">"&#123;\"result\":&#123;\"id\":1,\"name\":\"aa\",\"datetime\":\"2016-04-25 16:38:54\",\"status\":1&#125;, \</span></span><br><span class="line"><span class="hljs-string">        \"code\":10000,\"message\":\"ok\",\"sign\":901498365&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    u32 cID;</span><br><span class="line">    <span class="hljs-keyword">char</span> *pName;</span><br><span class="line">        <span class="hljs-keyword">char</span> *datetime;</span><br><span class="line">        u8 cStatus;</span><br><span class="line">&#125;SCAN_CODE_LIST_MEM_TypeDef;</span><br><span class="line"></span><br><span class="line">SCAN_CODE_LIST_MEM_TypeDef g_stScanCodeListMem;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">u8 <span class="hljs-title">ParseScanCodeJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pszJsonText)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    cJSON   *root, *result;</span><br><span class="line">    u32 code=<span class="hljs-number">0</span>;</span><br><span class="line">        u8 ret = FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//将json数据解析成json结构体</span></span><br><span class="line">    root= cJSON_Parse(pszJsonText);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (root)</span><br><span class="line">    &#123; </span><br><span class="line">            <span class="hljs-comment">//从根节点获取code元素的值 int型</span></span><br><span class="line">                code = cJSON_GetObjectItem(root, <span class="hljs-string">"code"</span>)-&gt;valueint;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(code != <span class="hljs-number">10001</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="hljs-comment">//从根节点获取result节点</span></span><br><span class="line">                        result = cJSON_GetObjectItem(root, <span class="hljs-string">"result"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-keyword">if</span> (result)</span><br><span class="line">                        &#123; </span><br><span class="line">                                <span class="hljs-comment">//从result节点获取各个元素的值</span></span><br><span class="line">                                g_stScanCodeListMem.cID =  cJSON_GetObjectItem(result, <span class="hljs-string">"id"</span>)-&gt;valueint; <span class="hljs-comment">//int 型</span></span><br><span class="line">                                g_stScanCodeListMem.pName = cJSON_GetObjectItem(result, <span class="hljs-string">"name"</span>)-&gt;valuestring;<span class="hljs-comment">//字符串型</span></span><br><span class="line">                                g_stScanCodeListMem.datetime = cJSON_GetObjectItem(result, <span class="hljs-string">"datetime"</span>)-&gt;valuestring;<span class="hljs-comment">//字符串型</span></span><br><span class="line">                                g_stScanCodeListMem.cStatus = cJSON_GetObjectItem(result, <span class="hljs-string">"status"</span>)-&gt;valueint;<span class="hljs-comment">//int 型</span></span><br><span class="line"></span><br><span class="line">                            <span class="hljs-comment">//保存扫描用户的名字  把id值也作为一个参数存入</span></span><br><span class="line">                                WriteScanCodeName(g_stScanCodeListMem.pName, g_stScanCodeListMem.cID);</span><br><span class="line"></span><br><span class="line">   <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG_APP_TASK        </span></span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" cID:%d "</span>, g_stScanCodeListMem.cID);       </span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" pName:%s"</span>, g_stScanCodeListMem.pName);              </span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" datetime:%s "</span>, g_stScanCodeListMem.datetime);</span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" cStatus:%d "</span>, g_stScanCodeListMem.cStatus);</span><br><span class="line">                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>                  </span></span><br><span class="line">                                ret = TRUE;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//释放资源</span></span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亦或者另一个实例，<a href="https://blog.csdn.net/hxlawf/article/details/90269458" target="_blank" rel="noopener">stm32使用cJSON库提取解析json数据例程</a></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">char</span> *out;cJSON *json,*jsonTemp;</span><br><span class="line"></span><br><span class="line">    json=cJSON_Parse((<span class="hljs-keyword">char</span> *)USART1_RX_BUF);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!json) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error before: [%s]\n"</span>,cJSON_GetErrorPtr());&#125;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        out=cJSON_Print(json);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s:%x:%x\n"</span>,out,json,out);</span><br><span class="line">        jsonTemp=cJSON_GetObjectItem(json,<span class="hljs-string">"name"</span>);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"name:%s\n"</span>,jsonTemp-&gt;valuestring);</span><br><span class="line">        jsonTemp=cJSON_GetArrayItem(json,<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"phone:%d\n"</span>,jsonTemp-&gt;valueint);</span><br><span class="line">        jsonTemp=cJSON_GetArrayItem(json,<span class="hljs-number">2</span>);</span><br><span class="line">        jsonTemp=cJSON_GetArrayItem(jsonTemp,<span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"params-area:%s\n"</span>,jsonTemp-&gt;valuestring);</span><br><span class="line">        cJSON_Delete(json);</span><br><span class="line">        myfree(SRAMEX,out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/2020/02/07/20190516183139772.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;目前对于ESP8266的了解还远远不够，只了解esp8266这款芯片是自带 &lt;strong&gt;mcu&lt;/strong&gt;的，网上搜索的关于ESP8266的教程都是基于ESP8266开发板展开的，所以开始对于如何使用这个模块很是懵逼，通过查找资料，对其有一定的了解，并且了解到在和stm32一起使用的时候需要使用AT相关的指令，目前对于这一块还不是很了解，但通过开发板的例程还是可以分析一点门路的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="硬件奇谈" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/"/>
    
      <category term="STM32" scheme="https://hztjiayou.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%A5%87%E8%B0%88/STM32/"/>
    
    
      <category term="stm32" scheme="https://hztjiayou.github.io/tags/stm32/"/>
    
      <category term="cjson" scheme="https://hztjiayou.github.io/tags/cjson/"/>
    
  </entry>
  
  <entry>
    <title>Linux只应该活在服务器里？</title>
    <link href="https://hztjiayou.github.io/2019/11/28/Linux%E5%8F%AA%E5%BA%94%E8%AF%A5%E6%B4%BB%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8C%EF%BC%9F.html"/>
    <id>https://hztjiayou.github.io/2019/11/28/Linux只应该活在服务器里？.html</id>
    <published>2019-11-28T09:39:02.000Z</published>
    <updated>2019-11-28T12:19:43.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><blockquote><p>Linux只应该活在服务器里吗？这篇文章是我使用linux这一年多来的感想，在一些linux论坛、知乎等社区，常常看到有人大肆吹捧linux大法好，甚至有言论称国外的大学生使用的都是linux操作系统，而我们还在很low的使用windows；这话曾经一度激起我放弃win，转向linux的决心,如今，虽然算不上过尽千帆，但也不再是当初的小白，故谈谈自己的看法。</p></blockquote><a id="more"></a><blockquote><p>本文应该会挺长，包括回顾自己从起初接触linux到后来慢慢熟悉的过程经历，以及自己的看法。</p></blockquote><hr><p>最初接触linux记得是在刚步入大学的时候，那时候的自己有着一腔热血的“信息安全”梦，在学习的过程中了解到了kali linux这个审计系统，于是稀里糊涂的跟着教程下载安装了VMware workstation、装了kali的虚拟机，那个时候自己连虚拟机是啥都不知道，只知道按照网上的教程一步步操作，犹记得当时中二的自己，<code>sudo apt-get update</code>和<code>sudo apt-get upgrade</code>这两个命令可以玩半天，觉得滚动的数据流超酷😄…..不过正是因为折腾kali，使得我了解了linux这个大家庭，可以说kali算是自己入门使用的linux发行版本，曾一度觉得kali是最好的linux发行版本（中二范，主要是觉得自己可以成为“黑客”，觉得很酷，好傻），后来不断的了解kali之后才知道自己当初的想法多么的滑稽。<br>通过kali使得我走进了linux的世界，后来自己前前后后折腾过<code>krinubuntu</code>、<code>ubuntu</code>、<code>debian</code>、<code>redhat</code>、<code>centos</code>、<code>deepin</code>、<code>manjaro</code>等，真的是用实际诠释了“生命不息，折腾不止”，现在回想，折腾真的是浪费时间呀，不过通过这些折腾也使得自己更加的了解linux和喜欢linux，不过自己折腾的这些都只是Linux的皮毛，linux的精髓和本质的知识自己并没有接触到，所以这激起了自己学习linux的内核、底层的兴趣，也就是在这个过程中使得自己更加的了解linux。<br>记得当初在网上看人说过一个事情，说他在使用国外的程序员分享的源码和文件的时候，发现压缩包的后缀尽是些<code>.tar.gz</code> <code>.tar.bz2</code>等，他看的一脸懵，后来他知道这是linux下常见的压缩格式，他了解之后说国外的大学生使用的系统都是linux的，而我们国内的学生使用的大多是win，当时这一席话看的我满腔热血，果断重装系统，直接全盘安装了<code>ubuntu</code>,可是！！！！当我正式开始使用的时候，我发现这“破”系统安装个软件需要折腾半天，因为很多win下生态很好的软件在linux上完全没有对应的版本，当时就只能懵逼了。<br>根据可查数据显示，在2019年NetMarketShare发布的一份全球桌面操作系统市场份额数据，windows10占据高达45.79%的比例，其次是windows7占据了35.38%，第3是苹果的macos，占据了5.31%，而linux排的第7位，占据1.55%的比例，前6位分别被微软和苹果两家的系统占据，而且微软更是占据碾压的优势，所以何来国外的大学生使用都是linux。<br>经过自己后来对linux的学习，linux毋庸置疑是一个强大的系统，但是在人机交互这方便，软件生态这方面是远远比不上windows的，我曾看人反驳说：我是用linux从来不适用图形界面；👏，你牛，你咋不上天呢，首先不说不适用图形界面怎么满足日常的办公需求（非IT人员），我就想问用个命令行还能用用处优越感来？科技在向前发展，能用方便、人性化、便捷的图形显示界面为什么还一定要用命令行呢？这句话不对linux运维、开发等技术人员，因为Linux运维开发，命令行的确不能替代。<br>所以我想说的是，如果你非技术人员，只是想使用一个清爽、高效、不折腾的办公系统，需要使用常见的办公软件office、QQ等，请远离linux！它不是为你准备的，如果你是业内人士，linux仍然不适合做你的主力系统，除非你热爱折腾，做好了折腾的准备，否则它只能是你的一个办公工具，一个开发平台，你服务器上的一个系统。<br>或许你说你不怕折腾，热爱折腾，好，假设你在ubuntu上折腾好了QQ、xxoffice(非微软)等，先不论这些软件使用起来放不方便，就说它使用起来稳不稳定？会不会频频出错？目前我觉得软件生态做的很好的如：deepin,国产linux发行版本，界面漂亮，使用起来基本没问题，可是我几次安装它，都给卸载了，因为系统不稳定，软件运行不稳定，系统偶尔小崩溃；还有如manjaro，这款系统我还是蛮喜欢的，安装软件的方法是我用过最爽的，但是我每次使用都会遇到一些小问题，如点击“系统设置”无反应，插入耳机有杂音等。<br>所以总的来说，虽然我热爱linux，但是我的主力电脑任然不会选择linux,它或许对我来说只是一个开发平台，或者只能躺在我的服务器里。</p><p>[END]</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Linux只应该活在服务器里吗？这篇文章是我使用linux这一年多来的感想，在一些linux论坛、知乎等社区，常常看到有人大肆吹捧linux大法好，甚至有言论称国外的大学生使用的都是linux操作系统，而我们还在很low的使用windows；这话曾经一度激起我放弃win，转向linux的决心,如今，虽然算不上过尽千帆，但也不再是当初的小白，故谈谈自己的看法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://hztjiayou.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://hztjiayou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="linux" scheme="https://hztjiayou.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>win神器Listary调用GoldenDict查词</title>
    <link href="https://hztjiayou.github.io/2019/11/23/win%E7%A5%9E%E5%99%A8Listary%E8%B0%83%E7%94%A8GoldenDict%E6%9F%A5%E8%AF%8D.html"/>
    <id>https://hztjiayou.github.io/2019/11/23/win神器Listary调用GoldenDict查词.html</id>
    <published>2019-11-23T12:12:20.000Z</published>
    <updated>2019-11-23T12:50:12.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><blockquote><p>这篇文章推荐一个win下超实用的软件，也是我安装系统之后首先要安装的，使用起来感觉非常的方便,并且结合其软件工具一起使用功能更加强大….<br><a id="more"></a></p></blockquote><p>今天要推荐的软件就是<code>listary</code>，一款win下超强大的文件搜索和辅助工具，使用起来类似于mac下的<code>launchbar</code>,使得打开应用和搜索文件变得效率极高，只要知道要搜索的应用或者文件中的个别文字，就可以检索出目标文件和软件，这一点有些类似win下另一款文件搜索软件<code>everything</code>，不过相比起来<code>listary</code>更加方便和强大，我最喜欢的是它双击<code>Ctrl</code>快捷键功能。<br>下面要说的是把<code>listary</code>和win下的字典软件<code>GoldenDict</code>结合起来，使得搜索单词只需要双击<code>Ctrl</code>调出<code>listay</code>即可方便搜索单词。<br>点击自定义-添加：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关键字：gd</span><br><span class="line">显示名称：search word with goldenDict</span><br><span class="line">路径： &lt;此处填写 goldenDict.exe 的完整路径，引号不是必须的&gt;</span><br><span class="line">参数： &#123;query&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章推荐一个win下超实用的软件，也是我安装系统之后首先要安装的，使用起来感觉非常的方便,并且结合其软件工具一起使用功能更加强大….&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://hztjiayou.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="win软件" scheme="https://hztjiayou.github.io/tags/win%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>My first cloud server</title>
    <link href="https://hztjiayou.github.io/2019/11/06/My-first-cloud-server.html"/>
    <id>https://hztjiayou.github.io/2019/11/06/My-first-cloud-server.html</id>
    <published>2019-11-06T11:08:08.000Z</published>
    <updated>2019-11-21T01:32:41.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><blockquote><p>近日在V2ex论坛，见<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客</a>这个网站的工作人员在搞活动，学生第一次在华为云购机，一年的学生服务器原价99元返现90元，抱着将信将疑的态度，在某日凌晨零点抢购了一台学生服务器，这也是本人的第一台服务器….<br><a id="more"></a></p></blockquote><p><del>因为华为云每日限购60台学生服务器，因此从11:55就在购买界面守候（双十一都没这么激动，好傻的样子），抢到服务器之后从激动慢慢变得一脸懵逼，心想：这玩意咋用？就如同当年第一次购入域名一样，对于这个这个听起来极其高大上的东西一头雾水（其实相比当初，自己现在还是强一点👀）。作为一个电子专业的小白，没啥优点，为数不多的优点就是脸皮厚，不懂就问，再不懂就问狗哥呗，还能难倒我咋的。秉着这样的精神，就有了下文。</del>（这不是真的）</p><hr><blockquote><p><strong>服务器配置</strong><br>1核CPU<br>2G内存<br>1M带宽<br>40G系统盘<br>系统：Ubuntu 18.04 server 64bit<br>9块钱一年，还要啥自行车…….</p></blockquote><p><br></p><h4 id="第一次折腾——搭建个人站点"><a href="#第一次折腾——搭建个人站点" class="headerlink" title="第一次折腾——搭建个人站点"></a>第一次折腾——搭建个人站点</h4><p>通过<code>putty</code>、<code>xshell</code>连接服务器，这很简单呀，输入公网IP，连接方式选择ssh，以root身份登录，输入密码，就可以通过本地电脑连接服务器了。<br>在网上看到很多人推荐用个人服务器加上wordpress搭建博客，因为觉得现有的博客放在github上挺好的，不想再折腾。但是了解到wordpress现已经发展到不只是个人博客那么简单了，还可以搭建个人网站，遂尝试一番。<br>作为刚入门，相当推荐使用<code>宝塔面板</code>来管理服务器，前面自己折腾使用命令行，配置错误又不知道怎么修改，重装了两次系统（菜），而使用<code>宝塔面板</code>来管理就方便许多了——轻度运维的福利呀。<br><a href="https://www.bt.cn/" target="_blank" rel="noopener">点击安装宝塔面板</a>，安装配合B站up主的视频食用：<a href="https://www.bilibili.com/video/av44358700?from=search&amp;seid=12287427164758627276" target="_blank" rel="noopener">B站视频</a></p><iframe src="//player.bilibili.com/player.html?aid=44358700&cid=77667784&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><strong><em>吐槽</em></strong>：满怀兴致的安装，结果在配置好域名（另外购买了个域名），安装好wordpess之后，被要求备案！！damnit,备案时间跨度得近20天，欲哭无泪（不管在哪购买的域名，只要服务器在国内，就要求备案）。就此中断一段时间，备案完成之后再折腾。</p><h4 id="小插曲-在虚拟机中搭建本地服务器"><a href="#小插曲-在虚拟机中搭建本地服务器" class="headerlink" title="[小插曲]在虚拟机中搭建本地服务器"></a>[小插曲]在虚拟机中搭建本地服务器</h4><blockquote><p>服务器这个东东，其实就是一台24小时开机的电脑，本质来说还是电脑，只是云服务器它有一个公网IP，而我在虚拟机中搭建一个服务器只能在本地访问（内网穿透也可以使它可在外网访问），所以区别就是不能在外网访问，但是可以让我在服务器漫长的备案期间折腾折腾，并且在本地折腾一遍练练手，可以提高在云服务器中配置功能的成功率呀。</p></blockquote><h5 id="配置虚拟机服务器"><a href="#配置虚拟机服务器" class="headerlink" title="配置虚拟机服务器"></a>配置虚拟机服务器</h5><p>虚拟机中服务器我采用的是<code>ubuntu server 18.**</code>的镜像，这是专门为服务器提供的镜像，大小只有800M左右，和<code>ubuntu</code>的发行版镜像不一样，这个服务器版是没有图形界面的，只有命令行界面，当然我觉得采用非服务器版镜像也行，比如：<code>centos</code>、<code>fedaro</code>等发行版。<br>配置好之后，还是在物理机上使用<code>Xshell</code>连接上虚拟机吧，方便~然后开启ssh,设置为开机自启动：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ssh #开启</span><br><span class="line">systemctl enable ssh #开机自启动</span><br></pre></td></tr></table></figure></p><h5 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h5><p>………..常规操作，安装宝塔面板……………<br><em>tips</em>:这有一个小问题，宝塔面板安装之后，它给出的<code>IP</code>是物理机的外网IP，所以如果正确的登录宝塔面板的后台需要把IP替换为虚拟机的<code>局域网IP</code>,端口<code>8888</code>不变。<br>然后又是常规操作，安装nginx等套件，PhP安装版本&gt;=7.2的版本，并且查看nginx和PhP是否正常开启。（我在这翻车就是因为nginx未启动）</p><h5 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h5><p>找到电脑路径<code>C:\Windows\System32\drivers\etc</code>下的<code>hosts</code>文件，增加“本地域名解析”<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的虚拟机IP    域名（随便）</span><br></pre></td></tr></table></figure></p><h5 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h5><p>这就基本上OK了，可以在网页中建立自己的网站啦，比如安装<code>wordpress</code>等。</p><hr><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>Damn it!! 备个案麻烦的要死，提交接入商之后被打回来一次，接入商通过之后，提交管局，等了7天，又被打回来了，原因是你要去你的户籍省份备案，我靠！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;近日在V2ex论坛，见&lt;a href=&quot;https://www.nowcoder.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客&lt;/a&gt;这个网站的工作人员在搞活动，学生第一次在华为云购机，一年的学生服务器原价99元返现90元，抱着将信将疑的态度，在某日凌晨零点抢购了一台学生服务器，这也是本人的第一台服务器….&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="云服务器" scheme="https://hztjiayou.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="云服务器" scheme="https://hztjiayou.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>manjaro配置</title>
    <link href="https://hztjiayou.github.io/2019/10/30/manjaro%E9%85%8D%E7%BD%AE.html"/>
    <id>https://hztjiayou.github.io/2019/10/30/manjaro配置.html</id>
    <published>2019-10-30T05:33:40.000Z</published>
    <updated>2019-11-28T02:01:14.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>偶然的机会了解到了manjaro这个linux发行版本，顿时被它迷住了，再加上win频频让我更新，导致我的vmware workstation不能使用好几次，故决定放弃win,给物理机安装manjaro;本文章是本人安装过程及学习过程的一系列记录，持续更新…….<br><a id="more"></a>  </p></blockquote><p>本文来自自己笔记整理，包括自己遇到的一些问题；主要讲讲一些使用方法和自己遇到并且解决的问题，至于安装过程google一大片，就不再论述。</p><h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><h4 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h4><p>配置中国的镜像</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -g  # 排列源，可不执行</span><br><span class="line">sudo pacman-mirrors -c China -m rank # 更改源，在跳出的对话框里选择想要的源</span><br></pre></td></tr></table></figure><p>增加arch中文社区的源，加速安装软件，在 <code>/etc/pacman.conf</code> 中添加 <code>archlinuxcn</code> 源，在其末尾加上：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>同步并更新系统：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure><p>安装 archlinuxcn-keyring 包以导入 GPG key，否则的话 key 验证失败会无法安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><h4 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h4><p>fcitx 是 Free Chinese Input Toy for X 的缩写，国内也常称作小企鹅输入法，是一款 Linux 下的中文输入法:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-googlepinyin</span><br><span class="line">sudo pacman -S fcitx-im # 选择全部安装</span><br><span class="line">sudo pacman -S fcitx-configtool # 安装图形化配置工具</span><br><span class="line">sudo pacman -S fcitx-skin-material</span><br></pre></td></tr></table></figure><p>解决中文输入法无法切换问题: 添加文件 ~/.xprofile：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure><p>输入法需要重启生效</p><h4 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h4><h5 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu    #对整个系统e进行更新</span><br><span class="line">pacman -Syy        #强制更新</span><br><span class="line">pacman -Syudd    #  使用 -dd跳过所有检测</span><br></pre></td></tr></table></figure><h5 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ss keyword在仓库中搜索含关键字的包（常用）pacman -Ss ‘^fcitx-’</span><br><span class="line">pacman -Qs keyword搜索已安装的包（常用）pacman -Qs ‘^fcitx-’</span><br><span class="line">pacman -Qi package_name查询本地安装包的详细信息</span><br><span class="line">pacman -Ql package_name列出该包的文件</span><br><span class="line">pacman -Fs keyword按文件名查找软件库</span><br><span class="line">pacman -Si package_name显示远程软件包的详尽的信息</span><br><span class="line">pacman -Qii package_name使用两个 -i 将同时显示备份文件和修改状态</span><br><span class="line">pacman -Ql package_name要获取已安装软件包所包含文件的列表</span><br><span class="line">pacman -Fl package_name查询远程库中软件包包含的文件</span><br><span class="line">pacman -Qk package_name检查软件包安装的文件是否都存在</span><br><span class="line">pacman -Fo /path/to/file_name查询文件属于远程数据库中的哪个软件包</span><br><span class="line">pacman -Qdt要罗列所有不再作为依赖的软件包(孤立orphans)</span><br><span class="line">pacman -Qet要罗列所有明确安装而且不被其它包依赖的软件包</span><br><span class="line">pactree package_name要显示软件包的依赖树</span><br><span class="line">whoneeds package_name检查一个安装的软件包被那些包依赖pkgtoolsAUR中的whoneeds</span><br><span class="line">pactree -r package_name检查一个安装的软件包被那些包依赖</span><br></pre></td></tr></table></figure><h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -S package_name执行 pacman -S firefox 将安装 Firefox（常用）你也可以同时安装多个包，只需以空格分隔包名即</span><br><span class="line">pacman -Sy package_name与上面命令不同的是，该命令将在同步包数据库后再执行安装。</span><br><span class="line">pacman -Sv package_name在显示一些操作信息后执行安装。</span><br><span class="line">pacman -U local_package_name安装本地包，其扩展名为pkg.tar.gz或pkg.tar.xz</span><br><span class="line">pacman -U url安装一个远程包（不在 pacman 配置的源里面）例：pacman -U http://www.example.com/repo/example.pkg.tar.xz</span><br></pre></td></tr></table></figure><h5 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sw package_name只下载包，不安装。</span><br><span class="line">pacman -Sc清理未安装的包文件（常用）</span><br><span class="line">包文件位于 /var/cache/pacman/pkg/ 目录</span><br><span class="line">pacman -Scc清理所有的缓存文件（常用）</span><br></pre></td></tr></table></figure><p><em>参考</em></p><ul><li><a href="https://wiki.archlinux.org/index.php/Category:%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">anki 简体中文</a></li><li><a href="https://wiki.archlinux.org/index.php/Pacman_%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">pacman简体中文</a></li><li><a href="https://www.archlinux.org/pacman/pacman.8.html" target="_blank" rel="noopener">pacman手册</a></li><li><a href="https://blog.csdn.net/nangy2514/article/details/93194184#4__49" target="_blank" rel="noopener">这篇博客</a></li></ul><h4 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h4><p>Yay 是用 Go 编写的 Arch Linux AUR 包管理工具。AUR 的全称是 Arch User Repository，是 Arch Linux/Manjaro 用户的社区驱动存储库，创建 AUR 的目的是使共享社区包的过程更容易和有条理。使用它可以在 Arch Linux/Manjaro 系统中安装和更新软件包。这个软件仓库的软件包是相当丰富，可以查看这个网站的统计<a href="https://repology.org/repositories/statistics/total" target="_blank" rel="noopener">Repository statistics</a>，它的软件列表可以在<a href="https://aur.archlinux.org/packages/" target="_blank" rel="noopener">Archlinux AUR</a>查看。具体可以查看 Arch Wiki</p><blockquote><p>注意：很多教程比较老了，yaourt 目前已经停止维护，用户可以考虑迁移到 aurman 或 yay</p></blockquote><p><strong>安装 yay：</strong></p><p>配置 yay 的 aur 源为清华源 AUR 镜像：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save</span><br></pre></td></tr></table></figure><p>修改的配置文件位于 ~/.config/yay/config.json ，还可通过以下命令查看修改过的配置:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -P -g</span><br></pre></td></tr></table></figure><p>yay 的常用命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yay -S package # 从 AUR 安装软件包</span><br><span class="line">yay -Rns package # 删除包</span><br><span class="line">yay -Syu # 升级所有已安装的包</span><br><span class="line">yay -Ps # 打印系统统计信息</span><br><span class="line">yay -Qi package # 检查安装的版本</span><br><span class="line">yay 安装命令不需要加 sudo。</span><br></pre></td></tr></table></figure><h4 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h4><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener">zsh</a>是一个非常好用的shell，具有强大的自动补全功能，尤其在使用pacman/yay安装软件时，可以自动补全软件名。</p><p> 以下方法经过自己多次实验，因为恶心的GFW存在，CTM的上个github都被限制，所以到第四步失效。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S zsh # 安装zsh</span><br><span class="line">echo $SHELL # 查看大概年前 shell</span><br><span class="line">chsh -s /bin/zsh # 修改默认shell，这个是修改当前用户的终端，如果要修改 root 账户，需要切换到 root用户</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line">sudo pacman -S autojump</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p><p>由于以上方法失效，建议可以使用此博主配置zsh的教程<a href="https://coreja.com/DailyHack/2019/08/config-your-super-zsh/" target="_blank" rel="noopener">zsh配置教程</a>  </p><h4 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># deepin 系的软件</span><br><span class="line">sudo pacman -S deepin-picker # 深度取色器</span><br><span class="line">sudo pacman -S deepin-screen-recorder # 录屏软件，可以录制 Gif 或者 MP4 格式</span><br><span class="line">sudo pacman -S deepin-screenshot # 深度截图</span><br><span class="line">sudo pacman -S deepin-system-monitor # 系统状态监控</span><br><span class="line">yay -s deepin-wine-wechat</span><br><span class="line">yay -S deepin-wine-tim</span><br><span class="line">yay -S deepin-wine-baidupan</span><br><span class="line">yay -S deepin.com.thunderspeed</span><br><span class="line">  </span><br><span class="line"># 开发软件</span><br><span class="line">sudo pacman -S jdk8-openjdk</span><br><span class="line">sudo pacman -S make</span><br><span class="line">sudo pacman -S cmake</span><br><span class="line">sudo pacman -S clang</span><br><span class="line">sudo pacman -S nodejs</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">sudo pacman -S goland</span><br><span class="line">sudo pacman -S vim</span><br><span class="line">sudo pacman -S maven</span><br><span class="line">sudo pacman -S pycharm-professional # Python IDE</span><br><span class="line">sudo pacman -S intellij-idea-ultimate-edition # JAVA IDE</span><br><span class="line">sudo pacman -S goland # Go IDE</span><br><span class="line">sudo pacman -S visual-studio-code-bin # vscode</span><br><span class="line">sudo pacman -S qtcreator # 一款QT开发软件</span><br><span class="line">sudo pacman -S postman-bin</span><br><span class="line">sudo pacman -S insomnia # REST模拟工具</span><br><span class="line">sudo pacman -S gitkraken # GIT管理工具</span><br><span class="line">sudo pacman -S wireshark-qt # 抓包</span><br><span class="line">sudo pacman -S zeal</span><br><span class="line">sudo pacman -S gitkraken # Git 管理工具</span><br><span class="line">  </span><br><span class="line"># 办公软件</span><br><span class="line">sudo pacman -S google-chrome</span><br><span class="line">sudo pacman -S foxitreader # pdf 阅读</span><br><span class="line">sudo pacman -S bookworm # 电子书阅读</span><br><span class="line">sudo pacman -S unrar unzip p7zip</span><br><span class="line">sudo pacman -S goldendict # 翻译、取词</span><br><span class="line">sudo pacman -S wps-office</span><br><span class="line">sudo pacman -S ttf-wps-fonts  #按装wps缺失字体  </span><br><span class="line">yay -S typora # markdown 编辑</span><br><span class="line">yay -S electron-ssr # 缺少我需要的加密算法</span><br><span class="line">yay -S xmind</span><br><span class="line">  </span><br><span class="line"># 设计</span><br><span class="line">sudo pacman -S pencil # 免费开源界面原型图绘制工具</span><br><span class="line">  </span><br><span class="line"># 娱乐软件</span><br><span class="line">sudo pacman -S netease-cloud-music</span><br><span class="line">  </span><br><span class="line"># 下载软件</span><br><span class="line">sudo pacman -S aria2</span><br><span class="line">sudo pacman -S filezilla  # FTP/SFTP</span><br><span class="line">  </span><br><span class="line"># 图形</span><br><span class="line">sudo pacman -S gimp # 修图</span><br><span class="line">  </span><br><span class="line"># 系统工具</span><br><span class="line">sudo pacman -S albert #类似Mac Spotlight，另外一款https://cerebroapp.com/</span><br><span class="line">yay -S copyq #  剪贴板工具，类似 Windows 上的 Ditto</span><br><span class="line">sudo pacman -S gufw#安装防火墙Linux 世界中最简单的防火墙之一</span><br><span class="line">  </span><br><span class="line"># 终端</span><br><span class="line">sudo pacman -S screenfetch # 终端打印出你的系统信息，screenfetch -A &apos;Arch Linux&apos;</span><br><span class="line">sudo pacman -S htop     #可以在终端中直接管理进程</span><br><span class="line">sudo pacman -S bat</span><br><span class="line">sudo pacman -S yakuake # 堪称 KDE 下的终端神器，KDE 已经自带，F12 可以唤醒</span><br><span class="line">sudo pacman -S net-tools # 这样可以使用 ifconfig 和 netstat</span><br><span class="line">yay -S tldr</span><br><span class="line">yay -S tig # 命令行下的 git 历史查看工具</span><br><span class="line">yay -S tree</span><br><span class="line">yay -S ncdu # 命令行下的磁盘分析器，支持Vim操作</span><br><span class="line">yay -S mosh # 一款速度更快的 ssh 工具，网络不稳定时使用有奇效</span><br><span class="line">systemctl start sshd.service #启动ssh</span><br></pre></td></tr></table></figure><p>OK，以上就是一些安装manjaro之后的常规配置</p><hr><h4 id="安装配置vmware-workstation"><a href="#安装配置vmware-workstation" class="headerlink" title="安装配置vmware workstation"></a>安装配置vmware workstation</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在manjaro的安装配置中，关于vmware的安装着实让我头疼;新建虚拟机打开出现错误</p><blockquote><p>could not open /dev/vmmon:?????? please make sure that the kernel moduel vmmon is load</p></blockquote><p>google、baidu搜索有遇到同样问题的，但是没有一个能够解决！！！前后折腾了许久，还选择安装了VirtulBox但是使用不习惯，后来突然醒悟可以去<code>manjaro</code>的论坛找找，这才找到解决方法。<br>感慨：</p><ul><li>使用linux真的可以很好锻炼自我解决问题的能力。</li><li><p>找资料要有的放矢，不能盲目,否则就是浪费时间，要缩小查找范围。</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5></li><li><p>使用manjaro提供的方法Install vmware-workstation</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pamac build vmware-workstation</span><br></pre></td></tr></table></figure></li><li><p>安装之后，重启你的设备，执行下面命令加载vmmon模块</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -a vmw_vmci vmmon</span><br></pre></td></tr></table></figure></li><li><p>Start and enable services（开启以及自启动服务）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable --now vmware-networks.service</span><br><span class="line">sudo systemctl enable --now vmware-usbarbitrator.service</span><br><span class="line">sudo systemctl enable --now vmware-hostd.service</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>上述服务的用处：<br>vmware-networks.service: Provides network access inside VMs, most people will want this enabled<br>vmware-usbarbitrator.service: Allows USB devices to be connected inside VMs<br>vmware-hostd.service: Enables sharing of VMs on the network</p></blockquote><p><em>至此，vmmon的问题应该完美解决了;如果你的问题还没有解决可以参考以下链接或者到manjaro frum提出问题</em><br><a href="https://wiki.manjaro.org/index.php?title=VMware#Installing_VMWare_Workstation_on_Manjaro" target="_blank" rel="noopener">Installing VMWare Workstation on Manjaro</a></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="解决QQ、Tim、网易云音乐、sublime中无法输入中文问题"><a href="#解决QQ、Tim、网易云音乐、sublime中无法输入中文问题" class="headerlink" title="解决QQ、Tim、网易云音乐、sublime中无法输入中文问题"></a>解决QQ、Tim、网易云音乐、sublime中无法输入中文问题</h4><p>待更新</p><h4 id="网络启停"><a href="#网络启停" class="headerlink" title="网络启停"></a>网络启停</h4><p>开机后显示wifi不可用，鼠标放在网络图标上显示<code>Networkmanager未运行</code>，解决方法是在终端执行以下命令</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart NetworkManager.service</span><br><span class="line">systemctl enable NetworkManager.service</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>后话：</strong><br>一番折腾过后，<del>打脸</del>，折腾来去发现还是win适合做自己的主力工具，linux只适合躺在虚拟机里，因为win的<del>笨笨</del>的使用方法，不需要去不断的折腾，可以更加注重于工作的内容，而不是环境，毕竟我们对待工具更多注重的是它的使用而不是它的开发和配置，再加上遇到各个问题需要自己不断去找答案，尤其在工作的时候。其实还有一个原因，折腾shadowsocks怎么都使用不了，我实在是忍受不了国内的网络环境，十个网址5个访问不了，访问速度慢的一批，故体验过manjaro之后，还是<del>打脸</del>的回到了win，真香，不过我是真的喜欢manjaro安装软件的方法，这是我见过最简单的安装方法，manjaro绝对是个优秀的发行版。说到底就是自己还太菜了吧…<em>fighting</em>💪💪💪</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;偶然的机会了解到了manjaro这个linux发行版本，顿时被它迷住了，再加上win频频让我更新，导致我的vmware workstation不能使用好几次，故决定放弃win,给物理机安装manjaro;本文章是本人安装过程及学习过程的一系列记录，持续更新…….&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="manjaro" scheme="https://hztjiayou.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>hexo增加aplayer音乐播放器及valine评论</title>
    <link href="https://hztjiayou.github.io/2019/10/10/hexo%E5%A2%9E%E5%8A%A0aplayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8.html"/>
    <id>https://hztjiayou.github.io/2019/10/10/hexo增加aplayer音乐播放器.html</id>
    <published>2019-10-10T03:04:18.000Z</published>
    <updated>2020-02-18T06:43:59.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文介绍在hexo博客中增加一个音乐播放器界面，可以放上自己喜欢的歌单；增加valine评论，使得每一篇文章都可留言评论。</p></blockquote><a id="more"></a><h3 id="aplayer音乐播放器"><a href="#aplayer音乐播放器" class="headerlink" title="aplayer音乐播放器"></a>aplayer音乐播放器</h3><p><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/1.png" alt></p><blockquote><p>aplayer是一款HTML音乐播放器，具有美观的播放界面，被广泛的使用在各大平台<a href="https://aplayer.js.org/#/" target="_blank" rel="noopener">样例展示</a>        <a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">github</a></p></blockquote><p>通过aplayer你可在你的博客中任意的添加喜欢的歌曲或者歌单<br><strong>单曲</strong><br>    <div id="aplayer-LbifumVA" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><br><strong>歌单</strong><br>    <div id="aplayer-StYzvEvh" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2122624496" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div></p><p>同时aplayer还提供<em>模拟模式</em>和<em>吸附模式</em>，可以参考官方文档<a href="https://aplayer.js.org/#/home?id=fixed-mode" target="_blank" rel="noopener">aplayer</a></p><hr><h4 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h4><p><strong>安装hexo-tag-aplayer插件</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure></p><p><strong>添加MeingJS 支持</strong><br>MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。<br>在Hexo配置文件<em>_config.yml</em>中添加<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br></pre></td></tr></table></figure></p><p><strong>使用</strong><br>在想加入音乐播放器的博客文章中加入如下配置：</p><p>加入单曲:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting &quot;3986040&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure></p><p>加入歌单:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting &quot;627070825&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure></p><p>配置参数：</p><table><thead><tr><th style="text-align:center"><strong>选项</strong></th><th style="text-align:center"><strong>默认值</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center"><strong>必须值</strong></td><td style="text-align:center">歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td style="text-align:center">server</td><td style="text-align:center"><strong>必须值</strong></td><td style="text-align:center">音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td style="text-align:center">type</td><td style="text-align:center"><strong>必须值</strong></td><td style="text-align:center"><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td style="text-align:center">fixed</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">开启固定模式</td></tr><tr><td style="text-align:center">mini</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">开启迷你模式</td></tr><tr><td style="text-align:center">loop</td><td style="text-align:center"><code>all</code></td><td style="text-align:center">列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td style="text-align:center">order</td><td style="text-align:center"><code>list</code></td><td style="text-align:center">列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td style="text-align:center">volume</td><td style="text-align:center">0.7</td><td style="text-align:center">播放器音量</td></tr><tr><td style="text-align:center">lrctype</td><td style="text-align:center">0</td><td style="text-align:center">歌词格式类型</td></tr><tr><td style="text-align:center">listfolded</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">指定音乐播放列表是否折叠</td></tr><tr><td style="text-align:center">storagename</td><td style="text-align:center"><code>metingjs</code></td><td style="text-align:center">LocalStorage 中存储播放器设定的键名</td></tr><tr><td style="text-align:center">autoplay</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td style="text-align:center">mutex</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td style="text-align:center">listmaxheight</td><td style="text-align:center"><code>340px</code></td><td style="text-align:center">播放列表的最大长度</td></tr><tr><td style="text-align:center">preload</td><td style="text-align:center"><code>auto</code></td><td style="text-align:center">音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td style="text-align:center">theme</td><td style="text-align:center"><code>#ad7a86</code></td><td style="text-align:center">播放器风格色彩设置</td></tr></tbody></table><p><br></p><h3 id="valine评论"><a href="#valine评论" class="headerlink" title="valine评论"></a>valine评论</h3><blockquote><p>本来评论打算使用的是gitalk，可是在折腾了一段时间后，遇到一个错误一直没有解决，听闻valine挺好用的，故而转向valine,<br>并且整个配置过程挺简单的。</p></blockquote><p><strong>注册Leancloud</strong><br>因为评论系统其实是放在Leancloud上的，首先需要去注册一个账号<br><a href="https://leancloud.cn/" target="_blank" rel="noopener">点我注册</a><br>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key<br>获取你的appid 和 appkey 如图所示：<br><img src="https://raw.githubusercontent.com/hztjiayou/Photos/master/Snipaste.jpg" alt><br><strong>修改主题的_config.yml</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 你的appid</span><br><span class="line">  app_key: 你的appkey</span><br><span class="line">  notify: false   #邮件提醒设置</span><br><span class="line">  verify: false   #验证码设置</span><br><span class="line">  placeholder: ヾﾉ≧∀≦)o快来评论一下吧!</span><br><span class="line">  avatar: monsterid  #头像设置</span><br><span class="line">  pageSize: 10</span><br><span class="line">  visitor: true</span><br></pre></td></tr></table></figure></p><p><strong>添加valine.ejs</strong><br>在<code>/layout</code>下创建<code>/comment</code>目录，在<code>/comment</code>下创建<code>valine.ejs</code>文件，在其中添加如下代码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!has_config(&apos;comment.app_id&apos;) || !has_config(&apos;comment.app_key&apos;)) &#123; %&gt;</span><br><span class="line">&lt;div class=&quot;notification is-danger&quot;&gt;</span><br><span class="line">    You forgot to set the &lt;code&gt;app_id&lt;/code&gt; or &lt;code&gt;app_key&lt;/code&gt; for Valine. Please set it in &lt;code&gt;_config.yml&lt;/code&gt;.</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;div id=&quot;valine-thread&quot; class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&apos;//unpkg.com/valine/dist/Valine.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Valine(&#123;</span><br><span class="line">        el: &apos;#valine-thread&apos; ,</span><br><span class="line">        notify: &lt;%= get_config(&apos;comment.notify&apos;) %&gt;,</span><br><span class="line">        verify: &lt;%= get_config(&apos;comment.verify&apos;) %&gt;,</span><br><span class="line">        app_id: &apos;&lt;%= get_config(&apos;comment.app_id&apos;) %&gt;&apos;,</span><br><span class="line">        app_key: &apos;&lt;%= get_config(&apos;comment.app_key&apos;) %&gt;&apos;,</span><br><span class="line">        placeholder: &apos;&lt;%= get_config(&apos;comment.placeholder&apos;) %&gt;&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p><strong>修改article.ejs文件</strong><br>在article文件最后添加如下代码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; has_config(&apos;comment.type&apos;)) &#123; %&gt;</span><br><span class="line">&lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;card-content&quot;&gt;</span><br><span class="line">        &lt;h3 class=&quot;title is-5 has-text-weight-normal&quot;&gt;&lt;%= __(&apos;article.comments&apos;) %&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;%- partial(&apos;comment/&apos; + get_config(&apos;comment.type&apos;)) %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>至此，valine配置完成，执行<code>hexo g</code>和<code>hexo d</code>更新</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文介绍在hexo博客中增加一个音乐播放器界面，可以放上自己喜欢的歌单；增加valine评论，使得每一篇文章都可留言评论。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="博客" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo主题" scheme="https://hztjiayou.github.io/tags/hexo%E4%B8%BB%E9%A2%98/"/>
    
      <category term="hexo" scheme="https://hztjiayou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>更换icarus主题</title>
    <link href="https://hztjiayou.github.io/2019/10/04/%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%8D%A2icarus%E4%B8%BB%E9%A2%98.html"/>
    <id>https://hztjiayou.github.io/2019/10/04/记录更换icarus主题.html</id>
    <published>2019-10-04T15:20:06.000Z</published>
    <updated>2020-02-18T06:44:34.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>本次参考<a href="https://removeif.github.io/" target="_blank" rel="noopener">removeif</a>的博客教程重新搭建了Hexo博客，顿时焕然一新，颇有生机，通过这次的升级真的是更深层次的了解了hexo框架和原理，同时看到人家的Blog做的这么漂亮、精致，自己禁不住也想做的如此优美。保证质量和排版漂亮，以及高质量图片的使用。</p><a id="more"></a></blockquote><h3 id="本次修改"><a href="#本次修改" class="headerlink" title="本次修改"></a>本次修改</h3><h4 id="修改一：删除最新推荐"><a href="#修改一：删除最新推荐" class="headerlink" title="修改一：删除最新推荐"></a>修改一：删除最新推荐</h4><p>因为目前还没有获取流量，所以整个意义也不大，故先删除。<br>删掉themes/icarus/layout/index.ejs中以下代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.path == &apos;index.html&apos;) &#123; %&gt;</span><br><span class="line">&lt;div class=&quot;tag is-white&quot; style=&quot;font-size:15px;&quot;&gt;热门推荐：&lt;/div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;div class=&quot;tags hot-tags&quot; id = &quot;index_hot_div&quot;&gt;</span><br><span class="line">加载中，稍等几秒...</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="修改二：删除最新评论"><a href="#修改二：删除最新评论" class="headerlink" title="修改二：删除最新评论"></a>修改二：删除最新评论</h4><p>删掉themes/icarus/_config.yml中中以下代码</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">    -</span><br><span class="line">        # Widget name</span><br><span class="line">        type: hot_comment</span><br><span class="line">        # Where should the widget be placed, left or right</span><br><span class="line">        position: right</span><br></pre></td></tr></table></figure><hr><h4 id="计划修改任务："><a href="#计划修改任务：" class="headerlink" title="计划修改任务："></a>计划修改任务：</h4><p>（√）修改“关注我”“GitHub facebook等”“个性签名”<br>（√）修改通知模块<br>（√）修改状态栏，2019 huangzhentao Powered by Hexo &amp; Icarus,Modify by removeif<br>（√）修改支付宝、微信二维码<br>（√）友链在本地预览时和配置的一样，部署之后还是原来作者的样子。hexo c解决问题<br>（√）手机浏览，最新推荐和评论可以显示，并且显示的是原来作者的热门文章<br>（）修改各分栏“留言”“友联”“美图”“影音” github快捷等<br>（×）修改以前博客图片的名字，不改了<br>（×）搞定gitalk！！！！,折腾了一个上午没弄出来。(采用了Valine评论)<br>（×）在搞定gitalk的前提下，增加热门和最新评论<br>（×）考虑是否把板娘给删除<br>（√）是否整理原来文章的分类<br>（）学习原博主的写作手法和风格<br>（）搞明白原来博主写的精简和完整版本<br>（）弄明白影音分栏是怎么做的</p><h5 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h5><p>+博客中上部状态栏中的<code>标签</code>显示的是tags：后面的标签，而<code>分类</code>显示的是categories: 后面的标签，一个是标签，一个是分类。+同时分类是有分级结构的，如：[工具教程,主题工具]，表示“主题工具”是“工具教程”的下级结构。</p><h5 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h5><p>1）图片先上传到github中，写博客的时候直接调用链接<br>2）使用.<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 上传图片，真方便！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本次参考&lt;a href=&quot;https://removeif.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;removeif&lt;/a&gt;的博客教程重新搭建了Hexo博客，顿时焕然一新，颇有生机，通过这次的升级真的是更深层次的了解了hexo框架和原理，同时看到人家的Blog做的这么漂亮、精致，自己禁不住也想做的如此优美。保证质量和排版漂亮，以及高质量图片的使用。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="博客" scheme="https://hztjiayou.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo主题" scheme="https://hztjiayou.github.io/tags/hexo%E4%B8%BB%E9%A2%98/"/>
    
      <category term="hexo" scheme="https://hztjiayou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>kali linux初始配置</title>
    <link href="https://hztjiayou.github.io/2019/09/12/00-kali-linux%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE.html"/>
    <id>https://hztjiayou.github.io/2019/09/12/00-kali-linux初始配置.html</id>
    <published>2019-09-11T16:23:03.000Z</published>
    <updated>2019-10-31T10:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>中文输入法配置、虚拟机全屏显示</p></blockquote><a id="more"></a><h3 id="中文输入法配置"><a href="#中文输入法配置" class="headerlink" title="中文输入法配置"></a>中文输入法配置</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fcitx fcitx-table-wbpy</span><br></pre></td></tr></table></figure><p>重启</p><p>配置 设置中的 language 为以下样</p><p><img src="/assets//img/yuyan.jpg" alt=" "></p><p>搞定，Ctrl+Space切换英中</p><h3 id="虚拟机全屏显示"><a href="#虚拟机全屏显示" class="headerlink" title="虚拟机全屏显示"></a>虚拟机全屏显示</h3><p>关于linux虚拟机不能能够自适应窗口大小这个问题很痛苦，查了很多资料，无非就是让你安装vm-tools，然后并没有什么用！！！！</p><p>最近发现一个很棒的解决方法，能够使得系统自适应窗口大小（窗口如果是缩小版，显示的也是整个系统的所有界面）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools</span><br><span class="line">sudo apt-get install open-vm*</span><br></pre></td></tr></table></figure><p>重启 完美解决</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;中文输入法配置、虚拟机全屏显示&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="kali linux" scheme="https://hztjiayou.github.io/tags/kali-linux/"/>
    
  </entry>
  
  <entry>
    <title>01 kali NC 命令使用</title>
    <link href="https://hztjiayou.github.io/2019/09/11/01kali-NC-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html"/>
    <id>https://hztjiayou.github.io/2019/09/11/01kali-NC-命令使用.html</id>
    <published>2019-09-11T12:04:00.000Z</published>
    <updated>2019-10-06T16:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>This article is about netcat<br><a id="more"></a><br>NETCAT——NC<br>功能介绍</p><ul><li>网络工具中的瑞士军刀——小身材，小智慧</li><li>侦听模式/传输模式</li><li>telnet/获取banner信息</li><li>传输文本信息——制作聊天功能</li><li>传输文件/目录</li><li>加密传输文件</li><li>远程控制/木马</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul></blockquote><hr><p>nc命令表<br><img src="/assets/img/nc1.jpg" alt></p><h3 id="nc构建“聊天”功能"><a href="#nc构建“聊天”功能" class="headerlink" title="nc构建“聊天”功能"></a>nc构建“聊天”功能</h3><p>使用到的命令<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 333#在pc1开启监听333端口</span><br><span class="line">nc -nv &#123;pc1&apos;s ip&#125; 333#在pc2连接333端口</span><br></pre></td></tr></table></figure></p><p>随后在任意pc中输入内容另一pc可收到<br><img src="/assets/img/pc.jpg" alt></p><h3 id="nc电子取证"><a href="#nc电子取证" class="headerlink" title="nc电子取证"></a>nc电子取证</h3><p>当一台服务器被入侵的时候，为了不在被入侵服务器上操作时候留下痕迹，可以使用nc命令将被入侵服务器上输出的信息传输回来  </p><p><img src="/assets/img/nc2.jpg" alt><br>上图的意思是PC1开启333端口进行监听，而PC2进行ls命令，检索当前文件下文件信息，并通过管道传输给PC1输出，可见在PC1中输出了相关文件信息，以起到不在PC2上留下痕迹的目的。<br>所用命令</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -nv -l -p 333</span><br><span class="line">ls -l | nc -nv &#123;pc1&apos;s ip&#125; 333 #管道重定向</span><br></pre></td></tr></table></figure><p>另外当输出信息太多事时候可以使用管道重定向到某个文件进行输出   </p><p><img src="/assets/img/nc3.jpg" alt>  </p><p>上图意思是PC1开启端口333监听，同时将监听结果重定向到ps.txt文件，PC2使用ps aux扫描进程，同时将进程结果用管道输出给PC1。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 333 &gt; ps.txt #结果重定向到ps.txt</span><br><span class="line">ps aux | nc -nv &#123;pc1&apos;s ip&#125; 333 -q 1 </span><br><span class="line">#上面的-q表示进程结束后延时_秒退出 后面1表示1s，用来表示命令结束</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;This article is about netcat&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://hztjiayou.github.io/categories/linux/"/>
    
    
      <category term="kali linux" scheme="https://hztjiayou.github.io/tags/kali-linux/"/>
    
      <category term="NC" scheme="https://hztjiayou.github.io/tags/NC/"/>
    
  </entry>
  
  <entry>
    <title>about ssr</title>
    <link href="https://hztjiayou.github.io/2019/08/26/about-ssr-v2ray.html"/>
    <id>https://hztjiayou.github.io/2019/08/26/about-ssr-v2ray.html</id>
    <published>2019-08-26T08:56:00.000Z</published>
    <updated>2019-11-11T15:22:33.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>SSR,全称为ShadowsockSocksR(SSR)，是ShadowSocks(SS)的一个衍生版本，相比于原版而言，主要增加了混淆参数功能；其主要被用在….<br><a id="more"></a></p></blockquote><h3 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h3><p>vpn 全称为Virtual Private Network（虚拟私人网络），说起vpn大家想到的都是科学上网，但是vpn的出现是在GFW建立起来之前，它原来的用处是在公用网络中建立起私用网路，用于加密传输，多用于高校、企业，如你在家想要接入学校的校园网，通过学校的vpn，你就可以接入学校的校园网。vpn有很多的具体实现，比如PPTP、L2TP、IPSec和openvpn等。它在被用于科学上网时有着许多缺点，最严重的就是流量特征过于明显，而GFW能够识别异常流量进行阻止，所以…..此种方法基本over.</p><h3 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h3><p>ssr的前身可以说时ss,ss是一个叫<a href="https://github.com/clowwindy" target="_blank" rel="noopener">clowwindy</a>的开发用来KXSW的，后来由于上传网络，效果太好被众多人使用，作者被请去喝茶了，后来删除代码，不再参与维护，现在的ss貌似是国外的大兄弟在维护。后来又有人在其基础上开发ssr，以下ssr（shadowsock）  </p><hr><p>很久以前我们访问网络是这样的，用户把请求直接通过互联网发送给服务提供商，服务提供商直接反馈给用户</p><p><img src="/assets/img/whats-shadowsocks-01.png" alt=" "></p><p>然后有一天GFW出现了，它就像一个收过路费的强盗夹在了用户和服务提供商之间，每当用户需要获取服务时候，需要经过GFW，当用户触发了GFW的拦截规则，就会受到Connection  reset 这样的回复，无法接收到正常的内容。</p><p><img src="/assets/img/whats-shadowsocks-02.png" alt="  "></p><p>聪明的人想到利用境外服务器代理的方法类绕过GFW的过滤，其中包含了各种HTTP代理服务，Socks等…..其中以ssh  tunnel的方法比较有代表性。</p><ul><li>1）首先用户和境外服务器通过ssh建立一条加密的通道。</li><li>2）用户通过建立的隧道进行代理，通过ssh服务器向服务商发起请求。</li><li>3）服务通过ssh服务器，再通过建立好的隧道返回给用户。<br><img src="/assets/img/whats-shadowsocks-03.png" alt="  "></li></ul><p>由于ssh本身就是基于RSA加密技术，所以GFW无法从加密的数据中进行关键词分析，避免了被重置链接的问题，但是由于创建隧道和数据传输过程中，ssh本身的特征是明显的，所以GFW一度通过分析链接的特征进行干扰，导致ssh存在被定向进行干扰的问题。</p><p>于是有人想了个办法，就是在你的电脑和SSH服务器上都同时安装shadowsocks ，就避免了被GFW干扰的问题。</p><p><img src="/assets/img/whats-shadowsocks-04.png" alt=" "></p><hr><p>参考：</p><ul><li><a href="https://ssr.tools/18" target="_blank" rel="noopener">https://ssr.tools/18</a></li><li><p><a href="https://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">https://vc2tea.com/whats-shadowsocks/</a></p></li><li><p><a href="https://medium.com/@thomas_summon/%E6%B5%85%E8%B0%88vpn-vps-proxy%E4%BB%A5%E5%8F%8Ashadowsocks%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB-b0198f92db1b" target="_blank" rel="noopener">https://medium.com/@thomas_summon/%E6%B5%85%E8%B0%88vpn-vps-proxy%E4%BB%A5%E5%8F%8Ashadowsocks%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB-b0198f92db1b</a></p></li><li><p><a href="https://deeponion.org/community/threads/vpnss-ssr.901/" target="_blank" rel="noopener">https://deeponion.org/community/threads/vpnss-ssr.901/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SSR,全称为ShadowsockSocksR(SSR)，是ShadowSocks(SS)的一个衍生版本，相比于原版而言，主要增加了混淆参数功能；其主要被用在….&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://hztjiayou.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="笔记" scheme="https://hztjiayou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
